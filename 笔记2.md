### HTTP原理和工作机制

#### 1.Http是什么 

用于传输超文本的协议 

HyperText Transfer Protocol超文本传输协议

超文本:在电脑中显示的,含有可以指向其他文本的链接的文本 就是HTML(文档的格式) 以及web api的数据

#### 2.HTTP的工作方式

浏览器 ->发送请求->服务器 , 服务器->响应->浏览器渲染

URL组成 http://github.com/user?gender=male

​         协议类型  服务器地址              路径

请求报文:

请求行(request line)  GET(请求方法method)  /user?gender=male(path)  HTTP/1.1(HTTP version)

 请求头(header)          HOST:github.com

​									 Content-Type:text/plain

请求体(body)              dadsfadfasdfdasf

响应报文:

状态行(响应行)  HTTP/1.1 200(status code) OK(code的简单描述)

响应头  Server:nginx/1.13.3

​			  content-Type:text/plain

响应体  [{"a":"b"},{}]



##### (1)请求的方法 Request Methods

GET 获取资源 没有body(可以有 但是做法不规范)

POST 增加或修改资源 有body

PUT  修改资源 有body

DELETE 删除资源 没有body 

HEAD 和get几乎一样 区别在于服务器不会返回body

get 和 put delete 都是幂等的 也就是说执行一次或多次结果 是一样的

##### (2)状态吗 status code

对结果做出类型化描述(如 成功 内容未找到)

为什么区分状态码:方便开发调试

1xx: 临时性消息  100 101告诉客户端我支持http2 不支持返回200

2xx: 成功

3xx: 重定向 301 永久迁移 302 临时迁移 一般都是301

4xx: 客户端错误

5xx: 服务器错误

##### (3) header

HTTP消息的元数据(metadata:数据的数据 或者说是数据的属性)

 Host:服务器主机地址  但是不是用来寻址的  在请求之前就已经通过DNS寻址了

作用:可能多个服务器主机地址是同一个IP 服务器需要做出判断所以需要携带HOST

 Content-Length:内容的长度(字节) 确定内容的长度(二进制内容)

 Content-Type/body的类型

​	text/html HTML文本,用于浏览器页面响应或post put请求

​	application/json json形式 用于web Api的响应

​	application/x-www-form-urlencoded 普通表单 encoded URL格式

​	multipart/form-data;boundary=----WebKitFormBoundary12938192ASDFA 多部分形式,一般用于传输包含二进制内容的多项内

​    image/jpeg  application/zip 提交单文件

Transfer-Encoding: chunked  分块传输 表示body长度无法确定,Content-Length不能使用

Location : https://www.baidu.com/ 重定向的目标URL
User-Agent: 用户代理 表示是浏览器 还是手机 标识等

Range/Accept-Range:断点续传 或分段下载

​	Accept-Range :bytes 表示支持分段下载

​	Range:bytes=0-15000 表示下载的范围

Cookie/Set-Cookie:发送Cookie/设置Cookie

Authorization:授权信息

Accept:客户端能接受的数据类型,如text/html;text/json

Accept-Charset:客户端接受的字符集,如utf-8

Accept-Encoding:客户端接受的压缩编码类型 如gzip

Content-Encoding;压缩类型,如gzip

Cache:Cache和Buffer的区别  cache缓存 buffer缓冲

 cache可能会重复使用

 buffer是针对工作流的 上游产生太快的缓冲等 在线播放提前下载进度是缓冲

​	Cache-Control :no-cache 可以缓存但需要先询问,no-store 不要缓存 max-age 失效日期前可以缓存

​	Last-Modified : Fri , 12 May 2006 18:53:33 GMT 去问服务器 在这个日期后 有改动吗 

​	Etag:If-None-Match 类似hash 标签 询问服务器最新资源是否还是这个tag

​	Cache-Control:private/public  告诉中间节点是否需要缓存 private不缓存 public可以缓存

#### 3.REST

是一种架构风格

RESTful HTTP 正确使用HTTP 

GET POST PUT DELETE 等正确的使用 



### 编码 加密 Hash 序列和字符集

#### 密码学

​	起源:古代战争  移位式加密:密码棒  替换式加密:替换文字 码表一一映射

#### 现代密码学

不止可以用于文字内容,还可以用于各种二进制数据

​	对称加密: 原数据 ->加密算法+密钥 -> 密文 ->解密算法+密钥->原数据

​		经典算法:DES(密钥短被逐渐弃用),AES



​	非对称加密: 原数据-> 加密算法+公钥->密文->加密算法+私钥->原数据

​	原理:使用公钥对数据进行加密得到密文,使用私钥对数据解密得到原数据

​		经典算法:RSA (加密解密都可以) DSA(签名专用) 问:公钥能不能解私钥加密的密文:能 但是公钥和私钥不能换 因为公钥可以被计算出来

​		延伸用途:数字签名与验证

​		原数据使用私钥加密后 发送签名数据和原数据 然后通过公钥加密 得到后比对原数据

​		原数据 -> 加密算法+私钥->签名数据-> 加密算法+公钥->原数据

加密+签名

对原数据用对方公钥加密得到密文 用自己私钥加密得到签名数据 发送给对方,对方使用自己的私钥加密得到原数据,用对方公钥验证得到原数据 比对两个数据是否一致

数据可能会很大 所以一般取原数据的hash值去进行验证签名

#### 密码学密钥和登录密码

密钥(key)   

场景:用于加密和解密

目的:保证数据被盗时不会被人读懂内容

焦点:数据

登录密码(password) 

场景: 用户进入网站或游戏前的身份验证

目的:数据提供方或应用服务方对帐号拥有者数据的保护,保证 [你是你] 的时候才提供权限

焦点:身份

#### Base64 

将二进制数据转换成由64个字符组成的字符串的编码算法

64个字符(a-zA-Z0-9+/)

什么是二进制数据:非文本数据就是二进制数据 广义:所有的数据都是二进制数据

用途:

​	让原数据具有字符串所具有的特性,如可以放在URL中传输,可以保存到文本文件,可以通过普通的聊天软件进行文本传输

​	把原本人烟可以读懂的字符串变成读不懂的字符串,降低偷窥风险

Base64加密传输图片,可以更安全和高效吗? 不安全也不高效

变种:Base58 去掉了几个字符 使用的地方 加密货币地址

##### URL encoding (Base64变种)

将URL中的保留字符使用百分号% 进行编码

目的:消除歧义,避免解析错误比如& / + 进行百分号编码 消除歧义

#### 压缩与解压缩

压缩:把数据换一种方式来存储,以减小存储空间

解压缩:把压缩后的数据还原成原先的形式,以便使用

常见压缩算法:DEFLATE(ZIP) JPEG(图片压缩) MP3(音乐)

压缩数据编码吗? 压缩数据是编码的一种

​	编码到底是什么意思? 按照一定规则将数据进行更改 编码后数据不会损失

##### 媒体数据的编解码

什么是图片 音频 视频的编解码

图片的编码:把图像数据写成 JPG PNG等文件的编码格式

图片的解码:把JPG,PNG等文件中的数据解析成标准的图像数据

音频 视频的编解码 和图片一样  有损压缩 无损压缩 

##### 序列化

序列化:把数据对象(一般是内存中的,例如JVM中的对象) 转换成字节序列的过程

反序列化:把字节序列重新转换成内存中的对象

目的:让内存中的对象可以被存储和传输

序列化是编码吗:严格来说不是

##### Hash(不可逆)

定义:把任意数据转换成指定大小范围(通常很小)的数据

作用:摘要,数字指纹

经典算法:MD5 SHA1 SHA256等

实际用途:

​	1.数据完整性验证:对原文件提供hash值 提供验证文件未被篡改

​	2.快速查找:hashCode() 和 HashMap hashCode会影响HashMap的存储

​	HashMap会去找key对应的hashcode的内存地址是否有数据 所以需要重写hashcode()方法 

​	hashcode是寻址用,equals是比较用 

​	3.隐私保护

Hash是编码吗?

不是,因为数据无法还原

Hash是加密吗?据说MD5是 不可逆加密

不是,加密是可以逆转的  

##### 字符集

含义:一个由整数向现实世界中的文字符号的Map

分支: 

ASCII  128个字符 1字节

ISO-8859-1 对ASCII进行扩充 1字节

​	Unicode	->UTF-8 UTF-16 同一字符集不同编码

GBK GB2312 GB19030 中国自研标准,多字节,字符集+编码



### 登录与授权 HTTPS和TCP/IP协议族

#### 登录和授权

Cookie

Cookie的工作机制

服务器需要保存的信息发送给客户端 客户端直接存储

response中有Set-Cookie的header保存服务器发送的header内容 客户端的request中使用Cookie的header 发送上次保存的header内容

Cookie的作用

​	会话管理:登录状态,购物车

​	个性化:用户偏好,主题
​	Tracking:分析用户行为

XSS(Cross-site scripting):HttpOnly  set-Cookie:sessionid=1;HttpOnly跨站脚本攻击

XSRF(Cross-site request forgery):Referer:www.google.com 跨站请求伪造

Authorization

Basic :Authorization:Basic 

Bearer:Authorization:Bearer token

​	OAuth2

​		OAuth2流程

​		微信登录就是一个完整的OAuth2流程

自家App中使用Bearer token 简化版的OAuth2流程

refresh_token

#### TCP/IP协议族

一系列协议所组成的一个网络分层模型

为什么要分层 因为网络不稳定

HTTP TCP IP LINK 

具体分层: 

​	Application Layer 应用层:HTTP FTP DNS

​	Transport Layer 传输层:TCP UDP

​	Internet Layer 网络层:IP

​	Link Layer 数据链路层: 以太网 Wi-Fi

#### TCP连接

什么叫做连接

TCP连接的建立和关闭 三次握手

长连接

​	为什么要长连接

​	长连接的实现方式:心跳

#### HTTPS

证书是如何验证的:证书的内容里有证书基本信息(域名等),公钥,证书签名算法以及签名,签发机构信息(基本信息,签发机构公钥,签发机构签名算法以及签名)

签名的内容:证书信息+证书公钥+证书签名算法 做hash签名,然后用签发机构的私钥对这个hash做一次加密(签名),

验证证书:

1.对证书信息使用相同的hash算法 做签名,然后用签发机构的公钥对服务器加密后的签名做一次加密运算,如果h1 == h2 则认为证书安全

连接过程

1. Client Hello  发送client_random 支持的算法等(tls版本 cipherSuites server Name client_random)
2. Server Hello  发送server_random 支持的算法等(tls版本 cipherSuites  server_random)
3. 服务器证书 信任建⽴ 客户端验证证书 (有的服务器也要验证客户端的证书 比如银行的U盾)
4. Pre-master Secret  客户端通过证书公钥加密Pre-master Secret 发送到服务器 然后根据client_random  server_random Pre-master Secret  通过一定的算法 生成加密通信的key
5. 客户端通知：将使⽤加密通信 
6. 客户端发送：Finished 
7. 服务器通知：将使⽤加密通信 
8. 服务器发送：Finished

 HTTP over SSL

SSL :Secure Socket Layer -> TLS Transport Layer Secure

定义:在HTTP之下增加的一个安全层,用于保障HTTP的加密传输

本质:在客户端和服务器之间协商出一个对称密钥,每次发送信息之前将内容加密,收到之后解密,达到内容的加密传输

为什么不直接用非对称加密? 太耗时



#### Retrofit 源码解析

create方法 生成代理API类

第一步 验证传过来的类是否是接口 是否是单独的接口 不能是继承的接口

第二步 是否要强制验证Interface的方法的合法性(适合调试但不利于性能)

第三步  通过动态代理创建接口实例 

动态代理三个参数 

​	第一个 类加载器 

​	第二个 要创建的类对象 可以是多个  动态代理会将这些接口的方法 全	部实现到一个类里 

​	第三个 一个InvocationHandler对象 里面有invoke方法 这个方法就是对这些接口的具体实现操作 当你通过代理拿到这个接口对象的时候 去调用接口里的方法 就是执行InvocationHandler里的invoke方法 就完成了接口的实现代理 其实就类似继承 只不过所有的方法的执行步骤 都是按照同样的代码逻辑去执行的

Retrofit代理的逻辑

​	第一步:如果方法是Object的类生命的方法 执行方法本身的代码逻辑

​	第二步: 判断是否是接口的默认接口实现方法 是的话也直接执行

​	上面都是为了兼容性做的	

​	第三步: retrofit实际的实现

​		(1) loadServiceMethod() :ServiceMethod

​			对方法进行解析(返回值 注解 参数等) 注解合法性验证 返回值类型和方法注解获取到对应的calladapter和converter

​			

​		(2)new OkHttpCall():OkHttpCall

​			根据(1)生成的ServiceMethod 以及method的参数 生成一个OkHttpCall()

​		(3)serviceMethod.adapt(OkHttpCall)

​		 切换线程 以及对各种返回值adapter的适配 比如rxjava2Adapter LiveDataAdapter 等等各种自定义的Adapter

#### OkHttp

dispatcher  控制请求 性能平衡 请求数量控制  maxRequests最大同时请求数 maxRequestsPerHost 最大同时请求同一个host的请求数

proxy 代理

List<Protocol> 告诉Okhttp支持的网络请求的协议的版本

List<ConnectionSpec> 链接规格  使用http还是https 使用SSL还是TLS  

以及TLS支持的各种算法 对称算法非对称算法 hash算法 CLEARTEXT 就是明文传输也就是HTTP

CookieJar cookie存储器

Cache 缓存

SocketFactory 创建端口 SSLSocketFactory  TCP连接叫socket

CertificateChainCleaner 整理后的证书链

HostnameVerifier Https使用的 主机名验证器

CertificatePinner 证书固定器 自签名的管理和验证 

Authenticator  做授权的

ConnectionPool 连接池 

Dns 根据域名获取ip地址列表

boolean follolwSslRedirects http到https 或者https到http是否允许

retryOnConnectionFailure 连接失败是否重试 

pingInterval 心跳包的间隔

dispatcher.enqueue方法: 判断请求是否超限 未超限则直接执行请求 超限则放入待请求的列表 

RealCall 

okhttp的Interceptor proceed方法  交给下一个intercept 并等待结果

类似于递归 intercept链子一样的调用proceed方法 直到最后一个intercept 最后一个不需要proceed 直接处理后返回  然后回到上一个intercept的proceed方法调用处

RetryAndFollowUpInterceptor 重试用

BridgeInterceptor 加各种request header 自动支持gzip   或者自己加的cookie

CacheInterceptor 对cache进行处理 自动的(需要自己配置cache)

ConnectInterceptor 做连接 TCP链接 TLS连接

CallServerInterceptor 拼接请求内容并向服务器发送请求 拿到返回结果给客户端处理

networkInterceptors 对网络数据直接做前置工作或者后置工作 一般用不到

interceptors 对最终结果处理的 一般使用这个

call.enqueue 受最大请求数量限制 call.execute() 不受最大请求数量限制



#### ViewModel 原理

获取ViewModel对象时  先检查ViewModelStore中是否已经有缓存 因为可能是旋转屏幕导致onCreate方法重新执行,

缓存是在onRetainNonConfigrationInstance方法保存在ViewModelStore中的 然后获取是在 getLastNonConfigrationInstance中获取 如果不为空则有缓存 那就直接拿到缓存 没缓存则创建

创建的过程是通过Factory创建的 Factory可以自定义 但是不能传入activity引用 因为ViewModel是在Activity销毁时才销毁 持有引用会导致内存泄漏

#### LiveData

LiveData在observe的时候绑定了LifeCycleOwner 一般来说就是我们的activity和fragment对象,之所以能够观察到生命周期的变化 是因为google已经让上一层的activity和frament实现了对生命周期的监听回调,我们只需要在对应的状态下做出对应的事就可以了 ,LiveData默认只有在onStart和onResume并且目标的数据版本号低于现在的版本号 才会对数据进行传输



#### Bitmap和Drawable

Bitmap是什么 位图 一个图像的完整的像素数据

Drawable是什么  像一个小型的专注的View

drawable存储的是一个绘制的规则 可能是位图 可能是颜色 等等 和View的绘制基本上一样 只不过上下左右是getBounds()的上下左右

自定义Drawable 有 主要方法是draw方法

自定义Bitmap 没有



#### 触摸反馈

 View.onTouchEvent源码分析

###### ACTION_DOWN

1.判断是否是可点击的 clickable

2.判断是否被设置为disabled 如果被设置了 返回 clickable 

3.判断touchDelegate是否存在 存在消费事件

4.如果 clickable == true || (viewFlags & TOOLTIP) == TOOLTIP 进入事件判断逻辑 否则返回false

(什么是TOOLTIP 就是一个属性 toolTipText  长按时会出现的提示 解释当前view是什么)

5.判断是否是触摸了实体按键(带键盘的手机),设置一个手指按下的flag

6.判断如果 clickable == false `检查长按`(触发toolTip)

7.判断是否是鼠标右键的按下(就是原来手机的那个菜单键) 如果是 显示一个菜单(现在基本无用)

8.判断是否在一个滑动的容器中 如果不是 设置为按下状态 `检查长按 `  ,如果是 设置一个点击等待器

等待器是个runnable runnable执行的代码和按下状态执行的基本一致

###### ACTION_MOVE

1.如果clickable == true,波纹(Ripple)中心 会随着手指改变

2.如果手指已经滑动到view外面  这次的系列事件就算结束  mTouchSlop 溢出 溢出的距离

移除点击和长按的Callback 就不会触发点击和长按事件了

###### ACTION_UP

1.去按下事件的状态

2.如果有TOOLTIP 显示tooltip

3.如果clickable ==false 移除点击和长按的监听 重置状态等

4.isFocusableInTouchMode() 含义 是否可以获取焦点在TouchMode 就是实体按键比如说电视 左右滑动就可以选中View

5.预按下状态的逻辑

6.触发点击时间

###### ACTION_CANCEL

1.初始化所有状态(移除点击事件 初始化状态)

#### ViewGroup 



#### Binder机制

binder三个优点:

高效,数据只需要拷贝一次(相对管道,消息队列,socket) ,共享内存是0次但是太复杂不好用

安全(相对传统IPC,比如socket的ip地址是可以被篡改的)  每个进程有UID

稳定(相对共享内存) 基于CS架构

linux应用的进程空间分为用户空间和内核空间,只有内核空间才可以进行进程间的数据交互

有一个运行在内核空间中的binder驱动程序负责进程的binder通信

传统IPC :`发送方`用户空间 发送数据调用copy_from_user()将数据拷贝到内核空间,`接收方`开辟一块内存空间通过copy_to_user()将数据拷贝到server用户空间 这样就导致了复制了两次数据,`接收方`也不知道数据大小 可能会导致内存浪费

Binder驱动: 接收方发送数据 通过copy_from_user()将数据发送到内核空间缓存区

binder通过内存映射 在内核空间和`接收方`的数据缓存区做了一层内存映射,这样`发送方`的数据拷贝到内核空间缓存区就等于直接拷贝到`接收方`的数据缓存区,等于减少了一次数据拷贝

1.binder驱动在内核空间创建一个 数据接收缓存区

2.再建立一个 内核缓存区 用来存储发送方的数据

3.建立两个缓存区之间的内存映射,以及 数据接收缓存区和数据接收方的内存映射

4.发送方通过系统调用copy_from_user() 将数据copy到内核的内核缓存区,因为内存映射的关系 相当于把数据发送到了数据接收方的用户空间 



 Binder通信流程 : 

1.Server 通过binder驱动 将自己能提供的服务`(binder的引用)`注册到serviceManager,serviceManager会建立一个映射表

2.client通过binder驱动,向serviceManager请求指定名称的Server的binder引用 也就是一个代理对象

3.client拿着这个引用 也就是binder的代理 调用对应服务的对应方法,同过binder驱动 调用到了Server自身的Binder的对应的方法

4.server执行完方法后 再通过binder驱动 将返回值 发送给client

每一步都有binder驱动的存在

对于client来说 binder就是一个server的引用

对于server来说 binder是自己具体实现的对象,要告诉serviceManager

对于serviceManager来说 binder就是binder名字和引用的映射

对于binder驱动来说 binder就是client和server沟通的桥梁



#### AIDL

transact() 远端对象(client端拿到的代理对象) 调用的方法 向server真正的binder对象发出调用

onTransact() 是远端对象(client端拿到的代理对象)能够响应接收到的调用

大概流程(存疑):Proxy.transact() -> Binder.onTransact() ->Proxy拿到结果

in  数据只能从客户端流向服务端

out 数据只能从服务端流向客户端

inout 数据可以双向流入

oneway 立即返回 不需要等待 可能aidl方法要执行两秒 但是我不管 我直接就跳过了 非阻塞



#### Android启动流程

1.开机键引导芯片加载BootLoader到内存 拉起系统OS

​	linux内核启动完毕后  寻找init.rc文件并启动init进程

2.init进程 

​	1 创建一些文件夹并挂载设备 

​	2) 初始化和启动属性服务 

​	3) 解析init.rc配置文件并启动zygote进程 

3.zygote进程 

​	1)创建AppRuntime并调用其start方法，启动Zygote进程。
​	2)创建DVM并为DVM注册JNI.
​	3)通过JNI调用ZygoteInit的main函数进入Zygote的Java框架层。
​	4)通过registerZygoteSocket函数创建服务端Socket，并通过runSelectLoop函数等待	ActivityManagerService的请求来创建新的应用程序进程。

​	5.启动SystemServer进程,通过fork方式启动,进程名为：system_server，启动的类名为：		com.android.server.SystemServer 

	zygoteinit的main方法
						(1) 创建Server端的socket
	
						(2) 预加载类和资源
	
						(3) 启动SystemServer进程
	
						(4) 等待AMS请求创建新的应用程序进程
4.SystemServer 主要用于创建系统服务

​	启动binder线程池

​	创建SystemServiceManager(用于对系统服务进行创建,启动和生命周期管理)

​	启动了各种服务 `优先级引导服务、核心服务和其他服务`  AMS PMS WMS等等

​	AMS启动Launcher应用(桌面)



#### APP启动流程

1.调用activity.startActivityForResult方法  最终转到mInstrumentation.execStartActivity()方法,因为Launcher是一个单独的进程 所以要跨进程告诉系统服务我要启动APP, 然后找到了ATMS(ActivityTaskManagerService) 然后使用AIDL,通过Binder进行通信

ATMS是AMS的一个延伸 之前这些工作都是AMS做的 现在分了一部分给ATMS 主要就是四大组件的调度工作 也是SystemServer启动的 

startActivity之后有一个checkStartActivityResult方法,如果activity启动失败 就会报异常 比如没注册manifest

2.ATMS收到启动消息后,就会通知上一个应用 也就是Launcher,让其进入Paused状态

startPausingLocked 会让上一个应用计入Paused状态 也就是Launcher 然后判断新的应用是否启动,如果启动 就会走ResumeActivityItem 方法 也就是控制Activity的onResume生命周期方法

如果应用没启动 就会走startSpecificActivityLocked 方法

3.ATMS判断应用进程是否已经启动,如果没有启动 创建进程,通过socket和Zygote通信,BufferedWriter读取消息,然后将新建进程消息给Zygote ,Zygote执行fork()方法,创建新进程并返回新进程的pid,

​	(为什么不用Binder? 因为fork不允许多线程,binder是多线程的,还有一点是为了防止死锁,因为假		如某个线程对某个锁lock了,另外一个线程去fork出新的进程,这个新的进程的锁是没人释放的,如果这	个新进程有人再用这个锁lock 就死锁了

4.ActivityThread

Zygote fork进程的同时, 也创建了ActivityThread对象, 也就是进程创建的时候 ActivityThread的main方法就被执行了, main方法创建了ActivityThread 创建主线程Looper并开始循环,并通知AMS,调用AMS.attachApplicationLocked() 方法 启动Application 并启动根Activity

5.创建Application

创建Instrumentation,也就是Launcher.startActivity中的这个Instrumentation 每一个APP都有一个Instrumentation 用于管理这个进程,比如创建activity 就会先执行到这

执行makeApplication 方法,最终执行到newApplication,执行了application的attach方法,然后去执行application的onCreate方法 attach还新建了phoneWindow 建立自己和window的关联等

6.启动activity

attach方法最终执行到ActivityThread的handleLauncheActivity()方法

初始化windowManagerGlobal 也就是WMS 然后创建ContextImpl 启动Activity 初始化activity的数据,设置主体,调用onCreate方法



启动流程简化版:

1.Launcher被调用点击事件,转到Instrumentation类的startActivity方法

2.Instrumentation通过binder告诉AMS要启动APP的需求

3.AMS反馈Launcher 让launcher进入paused状态

4.AMS转到ZygoteProcess类,通过socket和Zygote通信,告诉Zygote要建立新进程

5.Zygote fork新进程,并执行ActivityThread的main方法,也就是app的入口

6.ActivityThreade的main方法 创建ActivityThread的实例,并建立MainLooper 开启循环

7.与此同时ActivityThread也告诉AMS,进程创建完毕,开始创建Application Provider并调用application的attach oncreate等方法

8.创建上下文 通过类加载器加载activity 调用activity的生命周期方法 

启动完毕

#### activity启动流程

activity调用startActivityForResult 最终执行到Instrumentataion的startActivity方法

instrumentation通过binder访问AMS  AMS进行一系列工作,比如activity是否存在,启动模式,是否注册等

然后ClientlifeCycleManager 通过binder访问ActivityThread 

ActivityThread通过instrumentation的类加载器创建activity的实例,然后回调生命周期等方法





#### JVM

JVM结构包含 运行时数据区 执行引擎 本地方法库 本地方法接口 

类加载子系统补数据JVM虚拟机的内部构造

1.类的生命周期

​	一个java文件被加载到java虚拟机内存中到从内存中卸载的过程被称为类的生命周期

包括 加载,链接,初始化,使用,卸载 .链接包含三阶段: 验证,准备,解析 因此类的生命周期包括了7个阶段

​	1) 加载:查找并加载class文件

​	2) 链接:验证,准备 解析

​		验证:确保被导入类型的正确性

​		准备:为类的静态字段分配字段,并使用默认值初始化这个字段

​		解析:虚拟机将常量池内的符号引用替换为直接引用

​	3) 初始化:将类变量初始化为正确的初始值

​	4)使用:

​	5)卸载:

2.运行时数据区域  (JVM内存模型)

主要分为:程序计数器,栈,堆,方法区和本地方法区

​	1) 程序计数器:主要是为了保证程序能够连续的执行下去

​	程序计数器也叫PC寄存器,是一块较小的内存空间,在虚拟机的概念模型中,字节码解释器的工作就是通过改变程序计数器来选取下一条需要执行的字节码指令,java虚拟机的多线程是通过轮流切换并分配处理器执行时间来实现的,在一个确定的时刻只有一个处理器执行一条线程中的指令,因此为了保证线程切换后能回到正确的执行位置,每个线程都有一个独立的程序计数器 所以程序计数器是线程私有的

​	2) 栈:  

栈帧 = 局部变量表,操作数栈,动态连接 返回地址 四部分组成  

虚拟机栈

程序计数器

本地方法区

对象在堆中: 

​		对象头: MarkWord 类型指针 数组长度(对象是数组时)

​		具体数据

​		对齐填充

对象头:⽆锁状态中的 hashcode 是懒加载的，⼀个对象⼀旦计算过 hashcode 就被不会成为偏向锁。 ⽽ ⼀个偏向锁状态的对象，⼀旦计算过 hashcode (Object 默认的或者是 System 类提供的)，那 么会 ⽴即升级到重量级锁。 锁只能升级不能降级，⽆锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

​	

#### JVM垃圾回收

标记算法:

​	(1)引用计数算法:每个对象加计数器 有引用加1 没有了减少1 到0的时候 就认为没用了 可以GC

但是可能存在A和B两个对象互相引用 这样就导致了A和B都没法回收 所以这个算法一般不用

​	(2)根搜索算法(可达性分析算法),使用一系列的GC Roots的跟对象作为起始节点 根据引用关系向下搜索,走过的路径叫做引用链(Reference Chain),如果一个对象到GC Roots没有任何的引用链相连,就认为此对象可以被回收,就会进行标记

GC root :Garbage Collector root :Static对象,线程持有的对象,本地方法的引用 当前栈帧的引用

垃圾回收算法:

​	1.标记-清除算法:通过根搜索算法标记出需要回收的对象 然后进行统一回收

​	缺点:对象如果多的话 效率会低 因为要一个一个标记和回收,需要大量的时间

​		会引发内存碎片化问题,回收的对象一般都是不连续的,会产生很多的不连续的内存,然后导致		需要分配大对象的时候没有足够的连续空间

​	2.标记-复制算法

​	把内存划分为相等大小的两块 然后分配对象用其中一块 满了的时候 把存活对象复制到另外一半,然后用了的那块全部清除

​	缺点:相当于内存变成原来的一半,内存使用率低

​	3.标记-整理算法

​	标记好存活对象之后,把存活的对象一个一个的往内存的一端移动,移动完以后把边界外的内存全部清除掉

新生代和老年代用的算法不同

新生代: Eden和Survivor区域为8:1,使用标记复制算法

老年代:标记-整理算法或标记-清除算法



#### Handler

Looper.prepare():创建Looper对象 messageQueue 并持有当前线程引用

创建线程所属的Looper 先判断ThreadLocal是否持有 持有则报错

```java
private static void prepare(boolean quitAllowed) {
        // 规定了一个线程只有一个Looper，也就是一个线程只能调用一次Looper.prepare()
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        // 如果当前线程没有Looper，那么就创建一个，存到sThreadLocal中
        sThreadLocal.set(new Looper(quitAllowed));
    }
```

new Looper(): 创建messageQueue,并让Looper持有当前线程的引用

```java
 private Looper(boolean quitAllowed) {
        // 创建了MessageQueue，并供Looper持有
        mQueue = new MessageQueue(quitAllowed);
        // 让Looper持有当前线程对象
        mThread = Thread.currentThread();
    }
```

new Handler() :调用Looper.myLooper() 其实是调用sThreadLocal.get(),如果没有looper就抛异常

如果有 就拿到Looper的引用,Looper.messageQueue的引用,callback的引用

Looper.loop() 拿到messageQueue 并开始死循环,不停调用messageQueue.netx()取消息 如果没有 就通过native方法阻塞当前线程,如果有就调用msg.target.dispatchMesage(msg)方法去处理消息,target其实就是发送消息的handler对象,如果是使用callback方式的 就调用callback 如果不是 再判断他的mCallback 是不是空,不是空就调用mCallback.handleMessage并判断返回值,如果返回的是false 就调用handler自身的handleMessage (msg)方法

Looper.loop的作用就是不断的从messageQueue中取出message 并调用其回调方法,最后会执行message的recycleUnchecked方法 判断是否需要回收复用,判断的方法为已缓存的message对象是否超过50个,缓存的是一个单向链表

Handler 发送消息的几个方法 最终都会调用到sendMessageAtTime然后调用enqueueMessage

通过messageQueue自身的enqueueMessage方法,根据延迟的时间,把message放到合适的位置上,

message.Obtain() 先判断是否有缓存 如果有 从缓存中取



#### RecyclerView运行机制

ListView 缓存 RecycleBin里的ActiveView ScrapView

RecyclerView告诉LayoutManager要测量child ,LayoutManager去找Recycler要ViewHolder,Recycler根据是否有缓存来判断是否需要去找Adapter创建新的ViewHolder并返回给LayoutManager,ViewHolder中有itemView,也就是LayoutManager拿到了View 就可以开始测量了



​													RecyclerView

​				LayoutManager			Recycler						Adapter

​				ItemAnimator			ItemDecoration			ViewHolder

LayoutManager 对view进行测量,layout位置的摆放位置等

itemAnimator 提供view的动画

Adapter 把数据列表转换成RecyclerView需要的itemView 也就是提供view

viewHolder 

RecyclerViewPool 可以多个RecyclerView 公用一个回收池 就是直接recyclerView.setRecyclerViewPool. 

可以单独设置最大复用的ViewHolder容量

缓存机制 : 滑动时 先将划出屏幕外的ViewHolder回收到mCachedViews 默认最大值为2,然后 如果这个时候 屏幕划回来 就直接取到这个ViewHolder直接显示出来就可以了, 如果一直滑动  缓存的一直都是最新的2个ViewHolder,超出来的会被回收到RecyclerViewPool,每种类型默认最大缓存5个,

RecyclerViewPool 类似ListView的 RecycleBin的mScrapViews ,mCachedViews类似ListView的mActiveViews 但是ListView的mActiveViews 很少能用到



mAttachedScrap 用于临时保存数据没有变化的ViewHolder 

mChangedScrap 用于临时保存数据已经变化的viewHolder

pre-layout 数据改变前对应的布局 根据adapter给的信息(删除) 后一个item要前移 这样就确定了初始位置  获取mAttachedScrap +mChangedScrap  中的viewholder

 post-layout 数据改变后对应的布局 获取mAttachedScrap 中的viewHolder  无法获取到改变的viewHodler 需要去Pool和cachedView去找(或者新创建) 然后同一位置的两个viewHolder做配合 执行动画

预测性动画

动画需要两个viewHolder的配合 分别进行出场动画和进场动画

如何取消动画: recyclerView.setSupportChangeAnimations(false) 会取消所有的动画 不推荐

adapter.notifyItemChanged(position,"payload") ,就可以做到真正的局部刷新(不闪烁)

获取viewHolder的方法tryGetViewHolderForPositionByDeadline()

1.

- 1.从mAttachedScrap中获取
- 2.从HiddenView中获取
- 3.从CacheView获取

2.hasStablelds  需要对每一个item 设置一个单独的id 这个一般是notifydatasetchanged()的优化

3.ViewCacheExtension  一般没人用

4.RecyclerViewPool 取

都取不到 创建新的

RecyclerView 性能优化

1.onBindViewHolder 创建OnClickListener 不用使用匿名内部类对象,因为onBindViewHolder会执行多次,就会导致OnClickListener被创建多次

优化方式:可以在onCreateViewHolder里创建,或者提前创建好Listener,onBind的时候设置这个监听就可以了

2.LinearLayoutManager.setInitialPrefetchItemCount()

用户滑动的时候 由于需要创建更复杂的view 可能会导致页面卡顿

由于RenderThread的存在, RecyclerView会进行prefetch

setInitialPrefetchItemCount(count) count=横向列表初次显示可见的item个数,就是提前加载一些item 只有LinearLayoutManager内部嵌套才有用

3.recyclerView.setHasFixedSize() 

如果RecyclerView的大小是固定的 那就可以设置为true 这样就不会重新测量RecyclerView,

4.多个RecyclerView 共享RecyclerViewPool

5.DiffUtil



#### 插件化的原理

插件化目的:动态加载  动态部署,热更新

原理:通过类加载器加载类,通过反射调用对应类的方法

解决activity注册Manifest问题

​	1.通过代理Activity 欺骗系统 在对应生命周期调用插件里的Activity的对应方法

​	2.重写打包过程,合并manifest(不实用)

​	3.欺骗系统 在系统检查manifest之后 去启动另外一个activity

资源文件怎么办,图片什么的怎么办

​	重写getResources()和getAssets()方法

ClassLoader

 Bootstrap ClassLoader  启动类加载器

Extendsion ClassLoader 扩展类加载器

Application ClassLoader 应用程序类加载器 默认用这个

DexClassLoader 

dex:普通dex

odex: Optimized Dex 优化之后的dex 软件安装到手机之后 ,手机会对dex优化

AOT: Ahead-Of-Time Compilation 预先编译/解释 提前编译字节码

#### 热更新

和插件化的区别:

​	插件化的内容在原 App 中没有，⽽热更新是原 App 中的内容做了改动 

​	插件化在代码中有固定的⼊⼝，⽽热更新则可能改变任何⼀个位置的代码

ParentDelegate

双亲委托模型: 加载类的时候先让自己的父加载器尝试加载 加载不到 最后才自己加载 像是一个共享缓存 其实就是一直找parent类加载器找缓存

PathClassLoader.findClass()->BaseDexClassLoader.findClass()->DexPathList.findClass()->Element.findClass()->DexFile.loadClassBinaryName()

classloader的dex文件替换,直接修改字节码

ArtMethod  底层替换方案 就是替换指向的方法

借鉴Instant Run的原理 

#### HashMap 存放和获取速度都很快

数组 :内存中是连续的区域 访问速度快 增删慢

链表: 内存不是连续的区域 访问速度慢 增删快

hashmap是数组加链表 jdk1.8中 达到一定条件后链表会转换成红黑树

HashMap 1.7

对key做hash 获取int值 存放在数组对应位置

哈希碰撞如何解决:存放到hashmap的时候,如果对应位置已经有值了,比对他们的key的值,如果不一样,那么就通过链表的方式,存放多出来的key在数组的这个位置

hash的取值范围:对hash与数组长度-1做与运算,;就会存在数组同一位置存放了多个不同hash的key,取的时候就可以直接根据hash取 不需要比对key

HashMap里的Entry结构:key,value,next,hash 四个字段

HashMap 默认大小为16 临界值为12

HashMap key为null对应的值只有一个,key如果为null,会被放到索引为0的链表上

put的流程 获取hash,然后进行二次hash,降低碰撞几率, 然后hash与数组长度-1做与运算,把大数变成小数. 然后开始判断hash,key是否相等,如果相等就替换value,如果不存在就准备添加新的key-value,先判断是否需要扩容,如果不需要扩容就使用头插法 新的元素会放到链表的头上

hashmap扩容条件: 达到阈值,且对应位置是有值的才会进行扩容,每次扩容是上次的2倍,创建新的数组,把旧数组的内容转移到新的数组上,但是位置可能会变(50%几率),因为数组长度变了,计算出来的位置也变了,转移后 重新赋值table并重新计算阈值

get方法 如果是null 从0去找,如果不是null,拿到hash,根据hash拿到索引,然后去链表里去查找,找到同样的hash,key的值后返回,找不到 返回null

HashMap 1.8 数组+链表+红黑树

改动:

超过阈值就会扩容 不会再判断对应位置是否有值

新添加值不使用头插法 使用后插法

什么时候转换成红黑树: 链表长度超过8,并且数组长度不小于64

扩容后数据如何迁移: 重新计算索引后,算出自己新的高低位,然后直接插到对应位置的尾部

ArrayMap  二分查找法

扩容次数多 阈值低

- 1.数据量不大，最好在千级以内
- 2.数据结构类型为Map类型

ConcurrentHashMap 原理

1.7 segment

1.8 Node + CAS + synchronized

#### 二叉树



#### 性能优化

1.布局优化 用merge stub,

2.移除非必须的background

3.Hierarchy Viewer 分析布局

4.使用ArrayMap SparseArray代替HashMap(不建议说)

5.尽量不要使用枚举,占内存

6.Handler可定义为static的 或及时移除消息

7.静态变量不要持有activity引用

8.cursor io流的关闭

9.Memory Monitor 观察内存变化

10.使用更小的图片

11.对象的服用 比如message.obtain()

12.onDraw方法避免创建对象

13.activity引用的处理

14.应用到后台后关闭定位,视频播放等

15. Applicaiton中部分可以开线程去初始化





#### RxJava

onAssembly 钩子

subscribeActual 是订阅后实际做事的方法

Single的操作符实际就是创建一个中间人, 由下向上通知启动后,再由上向下调用onSubscribe方法,并执行对应的逻辑后 继续向下调用,最终给最后的订阅者,然后再从上向下调用onSuccess,一直向下传递到最后的订阅者

rxjava里observable的传递方式,桥接,移交 setOnce 或者replace 去实时替换

Disposable

Observable.interval 延迟发射 每隔几秒发送一个事件 

Rxjava的线程切换

RxJava2CallAdapterFactory.createWithScheduler(Scheduler.io()) 可以全部io发生请求

subscribeOn线程切换 使用Scheduler切换线程后,调用source.subscribe,也就是通知上游开始执行订阅

observeOn线程切换,收到结果后切换线程,最后的订阅者是最后一次observeOn的线程,每次observeOn都会切换线程



subscribeOn只有一次机会,只会控制最前面的,observeOn有多次机会 可以一直切 中间可以用doOnSuccess或者类似方法



#### MVC MVP MVVM

MVC：本意：虽然我看了论⽂，但它的本意我已经搞不清楚了，并且业界也是搞不清楚的态势；⽬前 较主流的理解：使⽤ Controller 来响应⽤户操作，并⽤ View 和 Model 分别来掌握视图和数据的逻 辑，Controller 可以和 View 及 Model 交互，有时 Model 也可以直接向 View 发送通知；Android 界 的较主流的理解：不使⽤任何额外的⼈为架构⼲预，把业务逻辑和对视图的操作都放进 Activity 中， 就是 MVC。 

MVP：单独创⽴ Presenter，⽤它分别与 View 和 Model 交互，实现⼆者的完全隔离，就是 MVP。 

MVVM：加⼊了双向绑定的 MVP。 

MVC 和 MVP 的对⽐：事实上按照⼤家⼝中所说的 MVC，很明显具有视图和业务逻辑关系过于紧密的 问题；MVP 由于把视图和业务逻辑分拆到了不同的类⾥，解决了这个问题，因此逻辑更清晰。但需要 注意：这种 View 和 Controller 紧密结合的 MVC 其实并不能算是 MVC 了，并且解决它的⽅式也只需 要把视图逻辑拆出来即可，并不是必须要把业务逻辑拆出来做成 Presenter。



#### Android构建流程 Android Gradle Plugin

构建的本质: 将java源代码 资源文件等 变成一个apk包

使用compileOnly 依赖gradle库 就可以看代码了

```groovy
compileOnly 'com.android.tools.build:gradule:3.0.1'
```

manifest->aapt2link->.ap_->zip->.apk

res -> aapt2 compile-> .flat -aapt2link->R.java->javac

.aidl -> aidl -> .java-> javac ->.class ->d8->.dex ->zip->.apk

.java->javac->.class->d8->.dex->zip->.apk

打包命令流程:

mkdir build 创建build文件夹

aapt2 compile -o build/res.zip --dir res 编译资源文件

aapt2 link build/res.zip  -I %ANDROID_HOME/platforms/android-29/android.jar --java build --manifest AndroidManifest.xml -o build/app-debug.apk 编译manifest

javac -d build -cp %ANDROID_HOME/platforms/android-29/android.jar com/\*\*/\*.java 编译java文件

d8 --output build --lib %ANDROID_HOME/platforms/android-29/android.jar build/com/\*\*/\*.class 打包成dex

zip -j build/app-debug.apk build/classes.dex 插入文件到apk

apksigner sign -ks ~/.android/debug.keystore build/app-debug.apk 签名 默认keystore密码是android

流程:

​	1.编译资源

​	2.链接资源 打包manifest,输出R文件等

​	3.编译java文件

​	4.dex编译

​	5.合并dex和资源文件

​	6.签名



#### java多线程

线程池流程: 添加runnable时,先判断coolPoolSize ,如果小于 启动新线程去做任务,如果大于 判断队列是否满,没满 放队列去等待被调度,如果满了,判断是否大于maximumPoolSize,不大于则创建新的线程去执行任务(这里创建的线程如果空闲时间超出,会被回收),大于就走对应的超出策略(比如报错,或者由runnable的线程去执行等操作)

 SingleExecutor 单线程

FixedExecutor 一次性的批量操作

ScheduledThreadPool 可以做延时

cachedThreadPool  缓存线程池 默认缓存60秒

###### ThreadPoolExecutor参数

corePoolSize 核心线程数 不会被回收

maximumPoolSize 最大线程数

keepAliveTime 保持线程不被回收的时间

Unit 时间单位

BlockingQueue 放runnable的队列

自定义线程池 : 自己设置参数

BlockingDeque =new LinkedBlockingDeque

根据CPU核心数分配线程有一定道理  不一样的机器性能会相对平衡



callable

```java
Future<String> future = executor.submit(callable);
try{
future.get();//get 是阻塞方法   future.isDone() 可以判断是否完成callable 
}catch(InterruptedException || ExecutionException e){
    e.printStackTrace();
}
```

进程和线程的区别:是否是共享数据

##### synchronized

修饰在方法上 调用的时候会加个monitor

monitor只允许一个线程去访问他所检视的方法

x++ 不是原子操作   : x++  等于int temp = x+1; x = temp;

原子操作:CPU级别的操作 不可能被线程中断,比如int x=1;

线程安全:互斥访问

所有加了syhchronized的方法 都会被同一个monitor检视,意义:保护资源不被乱更改

```java
synchronized void method(){}
等同于
void method2(){
synchronized(this){
	}
}
```

第一种的monitor就是这个类对象 第二种也是 ,但是第二种可以指定monitor

被同一个monitor的方法 不可以被同时访问

synchronized的作用: 1.保护资源 2.数据同步

synchronized会在代码块执行完毕后 同步到内存 所以效率会低一些

###### 死锁

```java
void method(){
    synchronized(monitor2){
        name = "3";
        synchronized(monitor1){
            value = "4";
        }
    }
}
void method2(){
    synchronized(monitor1){
        value = "5";
        synchronized(monitor2){
            name = "6";
        }
    }
}
```

method()执行到monitor2的代码块时, CPU切换线程到method2()然后执行,然后执行到第二个同步代码块的时候 因为锁没释放 就卡住了  就死锁了,两个线程就卡死了

###### volatile 

加上volatile 会使被修饰的变量具有原子性和同步性

volatile不能保证a++的原子性 因为a++ 是 a = a+1,是两步操作

volatile只对基本类型有效,对象只对赋值操作有效,指的是对象本身 而不是他的字段

原理:



###### AtomicXXXX 

AtomicInteger 保证各种操作(++)是原子性的

###### lock unlock

```java
Lock lock = new ReentrantLock();
void method(){
    lock.lock();
    x=1;
    //throw new Exception(); 会导致一直锁 需要try  finally里unlock(),synchronized会自动做这个
    lock.unlock();
}
//读写锁
ReentrantReadWriteLock lock2 = new ReentrantReadWriteLock();
ReentrantReadWriteLock.ReadLock readLock = lock2.readLock();
ReentrantReadWriteLock.WriteLock writeLock = lock2.writeLock();
void methodWrite(){
    writeLock.lock();
    try{
    x = 1;
        
    }finally{
        writeLock.unlock();
    }
}
void methodRead(){
    readLock.lock();
    try{
        System.out.println("x = " + x)
    }finally{
        readLock.unlock();
    }
}
```

读写锁,可以一起读,但是不能一起写



数据库相关的乐观锁和悲观锁

乐观锁: 拿到数据不加锁,修改数据后 写回去的时候 如果数据已经被改变了 则重新写一次

悲观锁:拿到数据加锁,写完后还回去直接覆盖 



#### 线程间交互

1.一个线程启动另一个线程

2.一个线程去终结另一个线程

thread.stop() 被弃用 因为结果不可预期 

thread.interrupt(); 标记线程为中断状态,需要自己在线程里判断,在该中断线程的地方去中断thread.interrupt() 如果是Thread.sleep触发的,只有那一瞬间是true,后面会被重置

wait(),notify()notifyAll() 需要在synchronized里

wait释放锁 notify会唤醒刚才需要锁的线程 继续执行代码

如何使用wait

```java
while(xxxx){
    try{
    	wait();        
    }catch (InterruptedException e){
        e.printStackTrace();
    }
}
```

thread.join() 调用join的线程 希望插队 等待插队进程完全执行完毕 再执行被插队进行的代码逻辑

 Thread.yield() 让出自己的执行时间 让自己或其他的线程执行 包含自己

 

ThreadLocal 每个线程持有的变量

AsyncTask 内存泄漏 是因为AsyncTask在运行,然后AsyncTask可能持有activity引用导致内存泄漏

AsyncTask导致内存泄漏的原因是因为内部有线程



多用Executor

Service和IntentService是在多线程之外有别的需求 再用

 

Lrucache 双向链表实现 每次get 或者put的时候 会把调用对象或者新进来的对象放到链表尾部,内存不够时,从头部开始remove

#### Glide



###### Glide.with() 

主要做了 线程池 + 缓存 + 请求管理与生命周期绑定+其它配置初始化的构建

Glide
 主要做一些 init 工作，比如缓存，线程池，复用池的构建等等。主要构建线程池、复用池、缓存策略、执行 Engine ，最后构建 Glide 实例 

RequestManagerRetriever
 主要是获得一个 RequestManager 请求管理类，然后绑定一个 Fragment 。

SupportRequestManagerFragment :
 用于管理请求的生命周期。

RequestManager
 主要用于对请求的管理封装

###### load

根据into方法的类,选择需要转换成的目标数据,比如drawable,bitmap,file等

###### into 

准备开始请求

请求之前先检查缓存,

在engine中先检查, 检查活动缓存(ActiveResources),再检查LruResourceCache

如果没有 就在EngineJob构建一个新的任务

执行request之前再去DiskCache中找,如果没有 再去网络请求

请求结果采样压缩拿到bitmap,然后对bitmap转换成drawable

构建磁盘缓存和内存缓存 然后通过DrawableImageViewTarget 显示到view上



View树绘制流程

 ActivityThread

```java
ActivityThread.performLaunchActivity()调用activity.attach方法中 创建出了phoneWindow

```

Activity.oncreate里调用setContentView(),回调到phoneWindow的setContentView()方法,然后调用了generateDecor()创建decorview

ActivityThread.handleResumeActivity中 windowmanager.addview将decorview添加到windowManager中,创建ViewRootImpl对象,绑定decorView,实际是WindowManagerImpl 到WindowManagerGlobal实现的

WindowManagerGlobal的addView 创建出了ViewRootImpl对象

然后调用ViewRootImpl.setView 绑定了decorView到ViewRootImpl并且去执行requestLayout方法

然后检查线程后就开始准备测量,布局,绘制的分发

requestlayout()里的scheduleTraversals  方法 发布一个runnable 去开始执行测量布局绘制遍历

 doTraversal ->performTraversals 开始执行遍历,如果是第一次遍历 会测量窗口大小

如果是第一次 先给view dispatchAttachedToWindow  把mAttachInfo分发给每个view

然后去调用viewTreeObserver的方法dispatchOnWindowAttachedChange方法

然后会去队列执行view.post缓存的runnable

performlayout之后调用viewTreeObserver dispatchOnGlobalLayout 分发

```
performMeasure
performLayout
performDraw
```



 #### ARouter

原理:在编译期解析@Route注解的类,把path和activity.class文件映射保存起来,通过build方法保存路径,然后通过navigation 匹配路径

 1、如果我们注解相同的path会怎么样？即有一个SecondActivity使用/a/b的path，而另一个ThirdActivity也使用/a/b的path，那么编译通得过吗？如果通得过的话，通过path获取的又是哪一个Activity呢？

答：如果在相同的module中，由于ARouter源码中使用的是Set，那么获取的是字母表排在前面的元素。如果在不同的module中，编译不过（和问题2一样）。

2、如果不同的module下，有两个Activity是相同的组会怎么样？即module1有一个SecondActivity使用/a/c的path，而module2也有一个ThirdActivity也使用/a/d的path，编译得过吗？

答：编译不过。由于都生成了相同的group文件，合并dex的时候会报错。

3、ARouter也可用于获取服务，假设采用通过接口的方式发现服务的话，如果接口不止一个实现，会怎样，会报错吗？

答：如果接口不止一个实现，并且接口的实现都用path注释的话，字母表排在后面的接口会覆盖掉排在前面的接口。

4、ARouter服务，为什么不能用抽象类继承IProvider然后实现抽象类而只能用接口继承IProvider然后实现该接口？

答：ARouter只处理了接口的情况，没有处理抽象类。

5、每次通过ARouter获取相同的path的服务，获取的都是同一个对象还是不同的对象？

答：每次通过ARouter的接口的方式发现服务，每次获取的都是同一个对象。

6、arouter-gradle-plugin的作用是什么？网上说ARouter加入apk后第一次加载会耗时，又是怎么回事？

答：arouter-gradle-plugin是一个插件，被ARouter用来加快应用安装后第一次进入时的速度。如果使用插件的话，那么会ASM直接插入字节码，省去了运行时需要扫描指定包名下面的所有className所造成的耗时。网上说ARouter加入apk后第一次加载会耗时，这是指的是没有使用arouter插件的时候，在第一次进入apk时，主线程必须等待子线程去扫描指定包名下面的所有className，如果class比较多，会比较耗时。

@autowired 原理

 在编译期通过 `AutowiredProcessor` 注解处理器生成对应的文件；

在运行期通过 `AutowiredServiceImpl` 根据名字反射对应的生成文件，调用 `inject()`；

如果未找到文件，则放入 `blackList`，若找到则缓存到 `classCache`；



 ####  Java I/O Okio

传统IO:程序内部(内存)和程序外部(文件,网络)进行数据交互的过程 就叫输入(把文件,网络的数据写入到内存)输出(把内存的数据输出到文件或网络)

普通I/O

FileOutputStream(File);FileInputStream(File);

```java
//写在try里 会自动关闭 java7特性
try(OutputStream outputStream = new FileOutputStream("./abc.txt");
    Writer reader = InputStreamWriter(outputStream);   
BufferedWriter bw = new BufferedWriter(reader)){
    bw.write('a');
    //如果用了java7特性 不需要下面这行代码 会自动输出
    //bw.flush();//把没输出完内容的做输出
}catch(FileNotFoundException e){
    
}catch(IOException e){
    
}


br.readLine();
```

```java
//文件复制
InputStream in = new FileInputStream("./old.txt");
OutputStream out = new FileOutputStream("./new.txt")
byte[] data = new byte[1024];
int read = -1;
while((read = in.read(data) != -1){
    out.write(data,0,read);
}
```

```java
//简易服务器Socket
void sockets(){
ServerSocket serverSocket =  new ServerSocket(8080);
    //和远方的socket建立连接,会一直阻塞 等待连接上
    Socket socket = serverSocket.accept();
    //获取客户端输入过来的流
    BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
    //获取向客户端输出的流
    BufferedWriter writer = new BufferedWriter(new OutPutStreamWriter(socket.getOutputStream()));
    String data;
    //等待客户端输入流,会阻塞 直到断开socket连接
   while((data = reader.readLine())!= null){
       //读到了客户端输入过来的数据后,给客户端输出过去
       writer.write(data)
           writer.write("\n")
           //writer.write(System.lineSeparator())
       writer.flush();
   } 
    
}

```



NIO 区别

1.管道叫Channel 是双向的 IO是单向的

2.强制使用buffer ,默认就是buffer但是不好用 ,IO是可以套buffer 不强制

3.非阻塞IO支持但是只是网络交互支持,文件不支持,文件还是阻塞

```java
//nio用法 
void nio(){
    RandomAccessFile file = new RandomAccessFile("/text.txt","rwd");
    FileChannel channel = file.getChannel();
    //byffer3个含义 postion 游标位置,当前在的位置 从哪里开始写或者开始读,limit 读写最多能移动到的位置, capacity容量
    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
    //将文件内容读到buffer
    channel.read(byteBuffer);
    //等于下面被注释掉这两行代码
    byteBuffer.flip();
    //将position的位置 赋值给limit
    //byteBuffer.limit(byteBuffer.position());
    //position移动到0
    //byteBuffer.position(0);
   System.out.println(Charset.defaultCharset().decode(byteBuffer));
    //重置postion 和limit的位置
    byteBuffer.clear();
}
```

```java
//nio 非阻塞 代码并不完全 
void nio2(){
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(8080));
    //关闭阻塞 也就是 改成非阻塞
    serverSocketChannel.configureBlocking(false);
    Selector selector = Selector.open();
    serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);
    SocketChannel socketChannel = serverSocketChannel.accept();
    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
    while(socketChannel.read(byteBuffer) != -1){
        //position赋值给limit positon重置
        byteBuffer.flip();
        //把数据写回去
        socketChannel.write(byteBuffer);
        //重置
        byteBuffer.clear();
    }
}
```

Okio 简单使用

Source 

Sink

```java
void okio1(){
    Source source = Okio.source("/text.txt");
    //加buffer 直接套一下就可以了
    //Source source = Okio.buffer(Okio.source("/text.txt"));
	Buffer buffer = new  Buffer();
    source.read(buffer,1024);
    //读buffer
    System.out.println(buffer.readUtf8());
    //读一行
    System.out.println(buffer.readUtf8Line());
    
    //sink 写入 source 输出
}
void okio2(){
    Buffer buffer = new Buffer();
    
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(buffer.outputStream());
objectOutputStream .writeUTF("ABC");
    objectOutputStream.writeBoolean(true);
    objectOutputStream.flush();//输出到buffer
    ObjectInputStream objectInputStream = new ObjectInputStream(buffer.inputStream());
    System.out.println(objectInputStream.readUTF());
  System.out.println(objectInputStream.readBoolean());
   
}
```



#### Gradle

buildTypes 除了debug release 还有internal,internal是给内部人员用的,配合productFlavors可以创建多个不同的打包规格

compile  api 依赖是传递的 compile api 没有区别只不过为了区分compile被遗弃了

implementation 依赖不会传递

#### Gradle Plugin

java assist ASM 两个工具 AOP

#### Annotation Processing Tools (APT)

annotation的意义:注释,就是给程序员看 给程序看的

@Interface

@Retention: 注解使用的范围

​	SOURCE:只是自己看  编译的时候就没了

​	CLASS:会保存到class中,但是虚拟机不一定看的到

​	RUNTIME:运行的时候也能看的见,一般用这个

@Target:谁能用

​		FIELD 字段可用

​		TYPE class可用

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface BindView{
	int value();//这个方法可以不写value = ,可以省略
	int id();

	String name() default "haha";//默认值

}

@BindView(id= 200,name = "haha")
```

```java
public class Binding {
    public static void bind(Activity activity){
        activity.findViewById();
    }
}
```

ButterKnife是依赖注入吗? 不是,是一个绑定框架,不是一个依赖注入框架

Dagger 是依赖注入  值从外部拿进来,注入进来,值是由外部决定的

值的决定权在外部 就是依赖注入,在内部 就不是依赖注入



在代码编译之前做操作,生成新的代码,执行时用新的代码去编译

利用Annotation Processing 使用注解自动生成代码

```java
public class BindingProcessor extends AbstractProcessor{
    public synchronized void init(...){
        
    }
    @Override
    public boolean process(...){
        
    }
    //设置支持的注解 比如 @Onclick 等
    @Override
    public Set<String> getSupportedAnnotationTypes(){
        return Collections.singleton(BindView.class.getCanonicalName());
    }
}
```

./gradlew : 28_annotation_processing:compileDebugJava



#### Walle 原理

apk sign block 插入渠道信息

