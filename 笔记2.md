### HTTP原理和工作机制

#### 1.Http是什么 

用于传输超文本的协议 

HyperText Transfer Protocol超文本传输协议

超文本:在电脑中显示的,含有可以指向其他文本的链接的文本 就是HTML(文档的格式) 以及web api的数据

#### 2.HTTP的工作方式

浏览器 ->发送请求->服务器 , 服务器->响应->浏览器渲染

URL组成 http://github.com/user?gender=male

​         协议类型  服务器地址              路径

请求报文:

请求行(request line)  GET(请求方法method)  /user?gender=male(path)  HTTP/1.1(HTTP version)

 请求头(header)          HOST:github.com

​									 Content-Type:text/plain

请求体(body)              dadsfadfasdfdasf

响应报文:

状态行(响应行)  HTTP/1.1 200(status code) OK(code的简单描述)

响应头  Server:nginx/1.13.3

​			  content-Type:text/plain

响应体  [{"a":"b"},{}]



##### (1)请求的方法 Request Methods

GET 获取资源 没有body(可以有 但是做法不规范)

POST 增加或修改资源 有body

PUT  修改资源 有body

DELETE 删除资源 没有body 

HEAD 和get几乎一样 区别在于服务器不会返回body

get 和 put delete 都是幂等的 也就是说执行一次或多次结果 是一样的

##### (2)状态吗 status code

对结果做出类型化描述(如 成功 内容未找到)

为什么区分状态码:方便开发调试

1xx: 临时性消息  100 101告诉客户端我支持http2 不支持返回200

2xx: 成功

3xx: 重定向 301 永久迁移 302 临时迁移 一般都是301

4xx: 客户端错误

5xx: 服务器错误

##### (3) header

HTTP消息的元数据(metadata:数据的数据 或者说是数据的属性)

 Host:服务器主机地址  但是不是用来寻址的  在请求之前就已经通过DNS寻址了

作用:可能多个服务器主机地址是同一个IP 服务器需要做出判断所以需要携带HOST

 Content-Length:内容的长度(字节) 确定内容的长度(二进制内容)

 Content-Type/body的类型

​	text/html HTML文本,用于浏览器页面响应或post put请求

​	application/json json形式 用于web Api的响应

​	application/x-www-form-urlencoded 普通表单 encoded URL格式

​	multipart/form-data;boundary=----WebKitFormBoundary12938192ASDFA 多部分形式,一般用于传输包含二进制内容的多项内

​    image/jpeg  application/zip 提交单文件

Transfer-Encoding: chunked  分块传输 表示body长度无法确定,Content-Length不能使用

Location : https://www.baidu.com/ 重定向的目标URL
User-Agent: 用户代理 表示是浏览器 还是手机 标识等

Range/Accept-Range:断点续传 或分段下载

​	Accept-Range :bytes 表示支持分段下载

​	Range:bytes=0-15000 表示下载的范围

Cookie/Set-Cookie:发送Cookie/设置Cookie

Authorization:授权信息

Accept:客户端能接受的数据类型,如text/html;text/json

Accept-Charset:客户端接受的字符集,如utf-8

Accept-Encoding:客户端接受的压缩编码类型 如gzip

Content-Encoding;压缩类型,如gzip

Cache:Cache和Buffer的区别  cache缓存 buffer缓冲

 cache可能会重复使用

 buffer是针对工作流的 上游产生太快的缓冲等 在线播放提前下载进度是缓冲

​	Cache-Control :no-cache 可以缓存但需要先询问,no-store 不要缓存 max-age 失效日期前可以缓存

​	Last-Modified : Fri , 12 May 2006 18:53:33 GMT 去问服务器 在这个日期后 有改动吗 

​	Etag:If-None-Match 类似hash 标签 询问服务器最新资源是否还是这个tag

​	Cache-Control:private/public  告诉中间节点是否需要缓存 private不缓存 public可以缓存

#### 3.REST

是一种架构风格

RESTful HTTP 正确使用HTTP 

GET POST PUT DELETE 等正确的使用 



### 编码 加密 Hash 序列和字符集

#### 密码学

​	起源:古代战争  移位式加密:密码棒  替换式加密:替换文字 码表一一映射

#### 现代密码学

不止可以用于文字内容,还可以用于各种二进制数据

​	对称加密: 原数据 ->加密算法+密钥 -> 密文 ->解密算法+密钥->原数据

​		经典算法:DES(密钥短被逐渐弃用),AES



​	非对称加密: 原数据-> 加密算法+公钥->密文->加密算法+私钥->原数据

​	原理:使用公钥对数据进行加密得到密文,使用私钥对数据解密得到原数据

​		经典算法:RSA (加密解密都可以) DSA(签名专用) 问:公钥能不能解私钥加密的密文:能 但是公钥和私钥不能换 因为公钥可以被计算出来

​		延伸用途:数字签名与验证

​		原数据使用私钥加密后 发送签名数据和原数据 然后通过公钥加密 得到后比对原数据

​		原数据 -> 加密算法+私钥->签名数据-> 加密算法+公钥->原数据

加密+签名

对原数据用对方公钥加密得到密文 用自己私钥加密得到签名数据 发送给对方,对方使用自己的私钥加密得到原数据,用对方公钥验证得到原数据 比对两个数据是否一致

数据可能会很大 所以一般取原数据的hash值去进行验证签名

#### 密码学密钥和登录密码

密钥(key)   

场景:用于加密和解密

目的:保证数据被盗时不会被人读懂内容

焦点:数据

登录密码(password) 

场景: 用户进入网站或游戏前的身份验证

目的:数据提供方或应用服务方对帐号拥有者数据的保护,保证 [你是你] 的时候才提供权限

焦点:身份

#### Base64 

将二进制数据转换成由64个字符组成的字符串的编码算法

64个字符(a-zA-Z0-9+/)

什么是二进制数据:非文本数据就是二进制数据 广义:所有的数据都是二进制数据

用途:

​	让原数据具有字符串所具有的特性,如可以放在URL中传输,可以保存到文本文件,可以通过普通的聊天软件进行文本传输

​	把原本人烟可以读懂的字符串变成读不懂的字符串,降低偷窥风险

Base64加密传输图片,可以更安全和高效吗? 不安全也不高效

变种:Base58 去掉了几个字符 使用的地方 加密货币地址

##### URL encoding (Base64变种)

将URL中的保留字符使用百分号% 进行编码

目的:消除歧义,避免解析错误比如& / + 进行百分号编码 消除歧义

#### 压缩与解压缩

压缩:把数据换一种方式来存储,以减小存储空间

解压缩:把压缩后的数据还原成原先的形式,以便使用

常见压缩算法:DEFLATE(ZIP) JPEG(图片压缩) MP3(音乐)

压缩数据编码吗? 压缩数据是编码的一种

​	编码到底是什么意思? 按照一定规则将数据进行更改 编码后数据不会损失

##### 媒体数据的编解码

什么是图片 音频 视频的编解码

图片的编码:把图像数据写成 JPG PNG等文件的编码格式

图片的解码:把JPG,PNG等文件中的数据解析成标准的图像数据

音频 视频的编解码 和图片一样  有损压缩 无损压缩 

##### 序列化

序列化:把数据对象(一般是内存中的,例如JVM中的对象) 转换成字节序列的过程

反序列化:把字节序列重新转换成内存中的对象

目的:让内存中的对象可以被存储和传输

序列化是编码吗:严格来说不是

##### Hash(不可逆)

定义:把任意数据转换成指定大小范围(通常很小)的数据

作用:摘要,数字指纹

经典算法:MD5 SHA1 SHA256等

实际用途:

​	1.数据完整性验证:对原文件提供hash值 提供验证文件未被篡改

​	2.快速查找:hashCode() 和 HashMap hashCode会影响HashMap的存储

​	HashMap会去找key对应的hashcode的内存地址是否有数据 所以需要重写hashcode()方法 

​	hashcode是寻址用,equals是比较用 

​	3.隐私保护

Hash是编码吗?

不是,因为数据无法还原

Hash是加密吗?据说MD5是 不可逆加密

不是,加密是可以逆转的  

##### 字符集

含义:一个由整数向现实世界中的文字符号的Map

分支: 

ASCII  128个字符 1字节

ISO-8859-1 对ASCII进行扩充 1字节

​	Unicode	->UTF-8 UTF-16 同一字符集不同编码

GBK GB2312 GB19030 中国自研标准,多字节,字符集+编码



### 登录与授权 HTTPS和TCP/IP协议族

#### 登录和授权

Cookie

Cookie的工作机制

服务器需要保存的信息发送给客户端 客户端直接存储

response中有Set-Cookie的header保存服务器发送的header内容 客户端的request中使用Cookie的header 发送上次保存的header内容

Cookie的作用

​	会话管理:登录状态,购物车

​	个性化:用户偏好,主题
​	Tracking:分析用户行为

XSS(Cross-site scripting):HttpOnly  set-Cookie:sessionid=1;HttpOnly跨站脚本攻击

XSRF(Cross-site request forgery):Referer:www.google.com 跨站请求伪造

Authorization

Basic :Authorization:Basic 

Bearer:Authorization:Bearer token

​	OAuth2

​		OAuth2流程

​		微信登录就是一个完整的OAuth2流程

自家App中使用Bearer token 简化版的OAuth2流程

refresh_token

#### TCP/IP协议族

一系列协议所组成的一个网络分层模型

为什么要分层 因为网络不稳定

HTTP TCP IP LINK 

具体分层: 

​	Application Layer 应用层:HTTP FTP DNS

​	Transport Layer 传输层:TCP UDP

​	Internet Layer 网络层:IP

​	Link Layer 数据链路层: 以太网 Wi-Fi

#### TCP连接

什么叫做连接

TCP连接的建立和关闭 三次握手

长连接

​	为什么要长连接

​	长连接的实现方式:心跳

#### HTTPS

 HTTP over SSL

SSL :Secure Socket Layer -> TLS Transport Layer Secure

定义:在HTTP之下增加的一个安全层,用于保障HTTP的加密传输

本质:在客户端和服务器之间协商出一个对称密钥,每次发送信息之前将内容加密,收到之后解密,达到内容的加密传输

为什么不直接用非对称加密? 太耗时



#### Retrofit 源码解析

create方法 生成代理API类

第一步 验证传过来的类是否是接口 是否是单独的接口 不能是继承的接口

第二步 是否要强制验证Interface的方法的合法性(适合调试但不利于性能)

第三步  通过动态代理创建接口实例 

动态代理三个参数 

​	第一个 类加载器 

​	第二个 要创建的类对象 可以是多个  动态代理会将这些接口的方法 全	部实现到一个类里 

​	第三个 一个InvocationHandler对象 里面有invoke方法 这个方法就是对这些接口的具体实现操作 当你通过代理拿到这个接口对象的时候 去调用接口里的方法 就是执行InvocationHandler里的invoke方法 就完成了接口的实现代理 其实就类似继承 只不过所有的方法的执行步骤 都是按照同样的代码逻辑去执行的

Retrofit代理的逻辑

​	第一步:如果方法是Object的类生命的方法 执行方法本身的代码逻辑

​	第二步: 判断是否是接口的默认接口实现方法 是的话也直接执行

​	上面都是为了兼容性做的	

​	第三步: retrofit实际的实现

​		(1) loadServiceMethod() :ServiceMethod

​			对方法进行解析(返回值 注解 参数等) 注解合法性验证 返回值类型和方法注解获取到对应的calladapter和converter

​			

​		(2)new OkHttpCall():OkHttpCall

​			根据(1)生成的ServiceMethod 以及method的参数 生成一个OkHttpCall()

​		(3)serviceMethod.adapt(OkHttpCall)

​		 切换线程 以及对各种返回值adapter的适配 比如rxjava2Adapter LiveDataAdapter 等等各种自定义的Adapter

#### OkHttp

dispatcher  控制请求 性能平衡 请求数量控制  maxRequests最大同时请求数 maxRequestsPerHost 最大同时请求同一个host的请求数

proxy 代理

List<Protocol> 告诉Okhttp支持的网络请求的协议的版本

List<ConnectionSpec> 链接规格  使用http还是https 使用SSL还是TLS  

以及TLS支持的各种算法 对称算法非对称算法 hash算法 CLEARTEXT 就是明文传输也就是HTTP

CookieJar cookie存储器

Cache 缓存

SocketFactory 创建端口 SSLSocketFactory  TCP连接叫socket

CertificateChainCleaner 整理后的证书链

HostnameVerifier Https使用的 主机名验证器

CertificatePinner 证书固定器 自签名的管理和验证 

Authenticator  做授权的

ConnectionPool 连接池 

Dns 根据域名获取ip地址列表

boolean follolwSslRedirects http到https 或者https到http是否允许

retryOnConnectionFailure 连接失败是否重试 

pingInterval 心跳包的间隔

dispatcher.enqueue方法: 判断请求是否超限 未超限则直接执行请求 超限则放入待请求的列表 

RealCall 

okhttp的Interceptor proceed方法  交给下一个intercept 并等待结果

类似于递归 intercept链子一样的调用proceed方法 直到最后一个intercept 最后一个不需要proceed 直接处理后返回  然后回到上一个intercept的proceed方法调用处

RetryAndFollowUpInterceptor 重试用

BridgeInterceptor 加各种request header 自动支持gzip   或者自己加的cookie

CacheInterceptor 对cache进行处理 自动的(需要自己配置cache)

ConnectInterceptor 做连接 TCP链接 TLS连接

CallServerInterceptor 拼接请求内容并向服务器发送请求 拿到返回结果给客户端处理

networkInterceptors 对网络数据直接做前置工作或者后置工作 一般用不到

interceptors 对最终结果处理的 一般使用这个



#### ViewModel 原理

获取ViewModel对象时  先检查ViewModelStore中是否已经有缓存 因为可能是旋转屏幕导致onCreate方法重新执行,

缓存是在onRetainNonConfigrationInstance方法保存在ViewModelStore中的 然后获取是在 getLastNonConfigrationInstance中获取 如果不为空则有缓存 那就直接拿到缓存 没缓存则创建

创建的过程是通过Factory创建的 Factory可以自定义 但是不能传入activity引用 因为ViewModel是在Activity销毁时才销毁 持有引用会导致内存泄漏

#### LiveData

LiveData在observe的时候绑定了LifeCycleOwner 一般来说就是我们的activity和fragment对象,之所以能够观察到生命周期的变化 是因为google已经让上一层的activity和frament实现了对生命周期的监听回调,我们只需要在对应的状态下做出对应的事就可以了 ,LiveData默认只有在onStart和onResume并且目标的数据版本号低于现在的版本号 才会对数据进行传输



#### Bitmap和Drawable

Bitmap是什么 位图 一个图像的完整的像素数据

Drawable是什么  像一个小型的专注的View

drawable存储的是一个绘制的规则 可能是位图 可能是颜色 等等 和View的绘制基本上一样 只不过上下左右是getBounds()的上下左右

自定义Drawable 有 主要方法是draw方法

自定义Bitmap 没有



#### 触摸反馈

 View.onTouchEvent源码分析

###### ACTION_DOWN

1.判断是否是可点击的 clickable

2.判断是否被设置为disabled 如果被设置了 返回 clickable 

3.判断touchDelegate是否存在 存在消费事件

4.如果 clickable == true || (viewFlags & TOOLTIP) == TOOLTIP 进入事件判断逻辑 否则返回false

(什么是TOOLTIP 就是一个属性 toolTipText  长按时会出现的提示 解释当前view是什么)

5.判断是否是触摸了实体按键(带键盘的手机),设置一个手指按下的flag

6.判断如果 clickable == false `检查长按`(触发toolTip)

7.判断是否是鼠标右键的按下(就是原来手机的那个菜单键) 如果是 显示一个菜单(现在基本无用)

8.判断是否在一个滑动的容器中 如果不是 设置为按下状态 `检查长按 `  ,如果是 设置一个点击等待器

等待器是个runnable runnable执行的代码和按下状态执行的基本一致

###### ACTION_MOVE

1.如果clickable == true,波纹(Ripple)中心 会随着手指改变

2.如果手指已经滑动到view外面  这次的系列事件就算结束  mTouchSlop 溢出 溢出的距离

移除点击和长按的Callback 就不会触发点击和长按事件了

###### ACTION_UP

1.去按下事件的状态

2.如果有TOOLTIP 显示tooltip

3.如果clickable ==false 移除点击和长按的监听 重置状态等

4.isFocusableInTouchMode() 含义 是否可以获取焦点在TouchMode 就是实体按键比如说电视 左右滑动就可以选中View

5.预按下状态的逻辑

6.触发点击时间

###### ACTION_CANCEL

1.初始化所有状态(移除点击事件 初始化状态)

#### ViewGroup 









