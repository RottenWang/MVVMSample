### HTTP原理和工作机制

#### 1.Http是什么 

用于传输超文本的协议 

HyperText Transfer Protocol超文本传输协议

超文本:在电脑中显示的,含有可以指向其他文本的链接的文本 就是HTML(文档的格式) 以及web api的数据

#### 2.HTTP的工作方式

浏览器 ->发送请求->服务器 , 服务器->响应->浏览器渲染

URL组成 http://github.com/user?gender=male

​         协议类型  服务器地址              路径

请求报文:

请求行(request line)  GET(请求方法method)  /user?gender=male(path)  HTTP/1.1(HTTP version)

 请求头(header)          HOST:github.com

​									 Content-Type:text/plain

请求体(body)              dadsfadfasdfdasf

响应报文:

状态行(响应行)  HTTP/1.1 200(status code) OK(code的简单描述)

响应头  Server:nginx/1.13.3

​			  content-Type:text/plain

响应体  [{"a":"b"},{}]



##### (1)请求的方法 Request Methods

GET 获取资源 没有body(可以有 但是做法不规范)

POST 增加或修改资源 有body

PUT  修改资源 有body

DELETE 删除资源 没有body 

HEAD 和get几乎一样 区别在于服务器不会返回body

get 和 put delete 都是幂等的 也就是说执行一次或多次结果 是一样的

##### (2)状态吗 status code

对结果做出类型化描述(如 成功 内容未找到)

为什么区分状态码:方便开发调试

1xx: 临时性消息  100 101告诉客户端我支持http2 不支持返回200

2xx: 成功

3xx: 重定向 301 永久迁移 302 临时迁移 一般都是301

4xx: 客户端错误

5xx: 服务器错误

##### (3) header

HTTP消息的元数据(metadata:数据的数据 或者说是数据的属性)

 Host:服务器主机地址  但是不是用来寻址的  在请求之前就已经通过DNS寻址了

作用:可能多个服务器主机地址是同一个IP 服务器需要做出判断所以需要携带HOST

 Content-Length:内容的长度(字节) 确定内容的长度(二进制内容)

 Content-Type/body的类型

​	text/html HTML文本,用于浏览器页面响应或post put请求

​	application/json json形式 用于web Api的响应

​	application/x-www-form-urlencoded 普通表单 encoded URL格式

​	multipart/form-data;boundary=----WebKitFormBoundary12938192ASDFA 多部分形式,一般用于传输包含二进制内容的多项内

​    image/jpeg  application/zip 提交单文件

Transfer-Encoding: chunked  分块传输 表示body长度无法确定,Content-Length不能使用

Location : https://www.baidu.com/ 重定向的目标URL
User-Agent: 用户代理 表示是浏览器 还是手机 标识等

Range/Accept-Range:断点续传 或分段下载

​	Accept-Range :bytes 表示支持分段下载

​	Range:bytes=0-15000 表示下载的范围

Cookie/Set-Cookie:发送Cookie/设置Cookie

Authorization:授权信息

Accept:客户端能接受的数据类型,如text/html;text/json

Accept-Charset:客户端接受的字符集,如utf-8

Accept-Encoding:客户端接受的压缩编码类型 如gzip

Content-Encoding;压缩类型,如gzip

Cache:Cache和Buffer的区别  cache缓存 buffer缓冲

 cache可能会重复使用

 buffer是针对工作流的 上游产生太快的缓冲等 在线播放提前下载进度是缓冲

​	Cache-Control :no-cache 可以缓存但需要先询问,no-store 不要缓存 max-age 失效日期前可以缓存

​	Last-Modified : Fri , 12 May 2006 18:53:33 GMT 去问服务器 在这个日期后 有改动吗 

​	Etag:If-None-Match 类似hash 标签 询问服务器最新资源是否还是这个tag

​	Cache-Control:private/public  告诉中间节点是否需要缓存 private不缓存 public可以缓存

#### 3.REST

是一种架构风格

RESTful HTTP 正确使用HTTP 

GET POST PUT DELETE 等正确的使用 



### 编码 加密 Hash 序列和字符集

#### 密码学

​	起源:古代战争  移位式加密:密码棒  替换式加密:替换文字 码表一一映射

#### 现代密码学

不止可以用于文字内容,还可以用于各种二进制数据

​	对称加密: 原数据 ->加密算法+密钥 -> 密文 ->解密算法+密钥->原数据

​		经典算法:DES(密钥短被逐渐弃用),AES



​	非对称加密: 原数据-> 加密算法+公钥->密文->加密算法+私钥->原数据

​	原理:使用公钥对数据进行加密得到密文,使用私钥对数据解密得到原数据

​		经典算法:RSA (加密解密都可以) DSA(签名专用) 问:公钥能不能解私钥加密的密文:能 但是公钥和私钥不能换 因为公钥可以被计算出来

​		延伸用途:数字签名与验证

​		原数据使用私钥加密后 发送签名数据和原数据 然后通过公钥加密 得到后比对原数据

​		原数据 -> 加密算法+私钥->签名数据-> 加密算法+公钥->原数据

加密+签名

对原数据用对方公钥加密得到密文 用自己私钥加密得到签名数据 发送给对方,对方使用自己的私钥加密得到原数据,用对方公钥验证得到原数据 比对两个数据是否一致

数据可能会很大 所以一般取原数据的hash值去进行验证签名

#### 密码学密钥和登录密码

密钥(key)   

场景:用于加密和解密

目的:保证数据被盗时不会被人读懂内容

焦点:数据

登录密码(password) 

场景: 用户进入网站或游戏前的身份验证

目的:数据提供方或应用服务方对帐号拥有者数据的保护,保证 [你是你] 的时候才提供权限

焦点:身份

#### Base64 

将二进制数据转换成由64个字符组成的字符串的编码算法

64个字符(a-zA-Z0-9+/)

什么是二进制数据:非文本数据就是二进制数据 广义:所有的数据都是二进制数据

用途:

​	让原数据具有字符串所具有的特性,如可以放在URL中传输,可以保存到文本文件,可以通过普通的聊天软件进行文本传输

​	把原本人烟可以读懂的字符串变成读不懂的字符串,降低偷窥风险

Base64加密传输图片,可以更安全和高效吗? 不安全也不高效

变种:Base58 去掉了几个字符 使用的地方 加密货币地址

##### URL encoding (Base64变种)

将URL中的保留字符使用百分号% 进行编码

目的:消除歧义,避免解析错误比如& / + 进行百分号编码 消除歧义

#### 压缩与解压缩

压缩:把数据换一种方式来存储,以减小存储空间

解压缩:把压缩后的数据还原成原先的形式,以便使用

常见压缩算法:DEFLATE(ZIP) JPEG(图片压缩) MP3(音乐)

压缩数据编码吗? 压缩数据是编码的一种

​	编码到底是什么意思? 按照一定规则将数据进行更改 编码后数据不会损失

##### 媒体数据的编解码

什么是图片 音频 视频的编解码

图片的编码:把图像数据写成 JPG PNG等文件的编码格式

图片的解码:把JPG,PNG等文件中的数据解析成标准的图像数据

音频 视频的编解码 和图片一样  有损压缩 无损压缩 

##### 序列化

序列化:把数据对象(一般是内存中的,例如JVM中的对象) 转换成字节序列的过程

反序列化:把字节序列重新转换成内存中的对象

目的:让内存中的对象可以被存储和传输

序列化是编码吗:严格来说不是

##### Hash(不可逆)

定义:把任意数据转换成指定大小范围(通常很小)的数据

作用:摘要,数字指纹

经典算法:MD5 SHA1 SHA256等

实际用途:

​	1.数据完整性验证:对原文件提供hash值 提供验证文件未被篡改

​	2.快速查找:hashCode() 和 HashMap hashCode会影响HashMap的存储

​	HashMap会去找key对应的hashcode的内存地址是否有数据 所以需要重写hashcode()方法 

​	hashcode是寻址用,equals是比较用 

​	3.隐私保护

Hash是编码吗?

不是,因为数据无法还原

Hash是加密吗?据说MD5是 不可逆加密

不是,加密是可以逆转的  

##### 字符集

含义:一个由整数向现实世界中的文字符号的Map

分支: 

ASCII  128个字符 1字节

ISO-8859-1 对ASCII进行扩充 1字节

​	Unicode	->UTF-8 UTF-16 同一字符集不同编码

GBK GB2312 GB19030 中国自研标准,多字节,字符集+编码



### 登录与授权 HTTPS和TCP/IP协议族

#### 登录和授权

Cookie

Cookie的工作机制

服务器需要保存的信息发送给客户端 客户端直接存储

response中有Set-Cookie的header保存服务器发送的header内容 客户端的request中使用Cookie的header 发送上次保存的header内容

Cookie的作用

​	会话管理:登录状态,购物车

​	个性化:用户偏好,主题
​	Tracking:分析用户行为

XSS(Cross-site scripting):HttpOnly  set-Cookie:sessionid=1;HttpOnly跨站脚本攻击

XSRF(Cross-site request forgery):Referer:www.google.com 跨站请求伪造

Authorization

Basic :Authorization:Basic 

Bearer:Authorization:Bearer token

​	OAuth2

​		OAuth2流程

​		微信登录就是一个完整的OAuth2流程

自家App中使用Bearer token 简化版的OAuth2流程

refresh_token

#### TCP/IP协议族

一系列协议所组成的一个网络分层模型

为什么要分层 因为网络不稳定

HTTP TCP IP LINK 

具体分层: 

​	Application Layer 应用层:HTTP FTP DNS

​	Transport Layer 传输层:TCP UDP

​	Internet Layer 网络层:IP

​	Link Layer 数据链路层: 以太网 Wi-Fi

#### TCP连接

什么叫做连接

TCP连接的建立和关闭 三次握手

长连接

​	为什么要长连接

​	长连接的实现方式:心跳

#### HTTPS

证书是如何验证的:证书的内容里有证书基本信息(域名等),公钥,证书签名算法以及签名,签发机构信息(基本信息,签发机构公钥,签发机构签名算法以及签名)

签名的内容:证书信息+证书公钥+证书签名算法 做签名(hash),然后用签发机构的私钥对这个签名做一次加密,

验证证书:

1.对证书信息使用相同的hash算法 做签名,然后用签发机构的公钥对服务器加密后的签名做一次加密运算,如果h1 == h2 则认为证书安全

连接过程

1. Client Hello  发送client_random 支持的算法等(tls版本 cipherSuites server Name client_random)
2. Server Hello  发送server_random 支持的算法等(tls版本 cipherSuites  server_random)
3. 服务器证书 信任建⽴ 客户端验证证书 (有的服务器也要验证客户端的证书 比如银行的U盾)
4. Pre-master Secret  客户端通过证书公钥加密Pre-master Secret 发送到服务器 然后根据client_random  server_random Pre-master Secret  通过一定的算法 生成加密通信的key
5. 客户端通知：将使⽤加密通信 
6. 客户端发送：Finished 
7. 服务器通知：将使⽤加密通信 
8. 服务器发送：Finished

 HTTP over SSL

SSL :Secure Socket Layer -> TLS Transport Layer Secure

定义:在HTTP之下增加的一个安全层,用于保障HTTP的加密传输

本质:在客户端和服务器之间协商出一个对称密钥,每次发送信息之前将内容加密,收到之后解密,达到内容的加密传输

为什么不直接用非对称加密? 太耗时



#### Retrofit 源码解析

create方法 生成代理API类

第一步 验证传过来的类是否是接口 是否是单独的接口 不能是继承的接口

第二步 是否要强制验证Interface的方法的合法性(适合调试但不利于性能)

第三步  通过动态代理创建接口实例 

动态代理三个参数 

​	第一个 类加载器 

​	第二个 要创建的类对象 可以是多个  动态代理会将这些接口的方法 全	部实现到一个类里 

​	第三个 一个InvocationHandler对象 里面有invoke方法 这个方法就是对这些接口的具体实现操作 当你通过代理拿到这个接口对象的时候 去调用接口里的方法 就是执行InvocationHandler里的invoke方法 就完成了接口的实现代理 其实就类似继承 只不过所有的方法的执行步骤 都是按照同样的代码逻辑去执行的

Retrofit代理的逻辑

​	第一步:如果方法是Object的类生命的方法 执行方法本身的代码逻辑

​	第二步: 判断是否是接口的默认接口实现方法 是的话也直接执行

​	上面都是为了兼容性做的	

​	第三步: retrofit实际的实现

​		(1) loadServiceMethod() :ServiceMethod

​			对方法进行解析(返回值 注解 参数等) 注解合法性验证 返回值类型和方法注解获取到对应的calladapter和converter

​			

​		(2)new OkHttpCall():OkHttpCall

​			根据(1)生成的ServiceMethod 以及method的参数 生成一个OkHttpCall()

​		(3)serviceMethod.adapt(OkHttpCall)

​		 切换线程 以及对各种返回值adapter的适配 比如rxjava2Adapter LiveDataAdapter 等等各种自定义的Adapter

#### OkHttp

dispatcher  控制请求 性能平衡 请求数量控制  maxRequests最大同时请求数 maxRequestsPerHost 最大同时请求同一个host的请求数

proxy 代理

List<Protocol> 告诉Okhttp支持的网络请求的协议的版本

List<ConnectionSpec> 链接规格  使用http还是https 使用SSL还是TLS  

以及TLS支持的各种算法 对称算法非对称算法 hash算法 CLEARTEXT 就是明文传输也就是HTTP

CookieJar cookie存储器

Cache 缓存

SocketFactory 创建端口 SSLSocketFactory  TCP连接叫socket

CertificateChainCleaner 整理后的证书链

HostnameVerifier Https使用的 主机名验证器

CertificatePinner 证书固定器 自签名的管理和验证 

Authenticator  做授权的

ConnectionPool 连接池 

Dns 根据域名获取ip地址列表

boolean follolwSslRedirects http到https 或者https到http是否允许

retryOnConnectionFailure 连接失败是否重试 

pingInterval 心跳包的间隔

dispatcher.enqueue方法: 判断请求是否超限 未超限则直接执行请求 超限则放入待请求的列表 

RealCall 

okhttp的Interceptor proceed方法  交给下一个intercept 并等待结果

类似于递归 intercept链子一样的调用proceed方法 直到最后一个intercept 最后一个不需要proceed 直接处理后返回  然后回到上一个intercept的proceed方法调用处

RetryAndFollowUpInterceptor 重试用

BridgeInterceptor 加各种request header 自动支持gzip   或者自己加的cookie

CacheInterceptor 对cache进行处理 自动的(需要自己配置cache)

ConnectInterceptor 做连接 TCP链接 TLS连接

CallServerInterceptor 拼接请求内容并向服务器发送请求 拿到返回结果给客户端处理

networkInterceptors 对网络数据直接做前置工作或者后置工作 一般用不到

interceptors 对最终结果处理的 一般使用这个



#### ViewModel 原理

获取ViewModel对象时  先检查ViewModelStore中是否已经有缓存 因为可能是旋转屏幕导致onCreate方法重新执行,

缓存是在onRetainNonConfigrationInstance方法保存在ViewModelStore中的 然后获取是在 getLastNonConfigrationInstance中获取 如果不为空则有缓存 那就直接拿到缓存 没缓存则创建

创建的过程是通过Factory创建的 Factory可以自定义 但是不能传入activity引用 因为ViewModel是在Activity销毁时才销毁 持有引用会导致内存泄漏

#### LiveData

LiveData在observe的时候绑定了LifeCycleOwner 一般来说就是我们的activity和fragment对象,之所以能够观察到生命周期的变化 是因为google已经让上一层的activity和frament实现了对生命周期的监听回调,我们只需要在对应的状态下做出对应的事就可以了 ,LiveData默认只有在onStart和onResume并且目标的数据版本号低于现在的版本号 才会对数据进行传输



#### Bitmap和Drawable

Bitmap是什么 位图 一个图像的完整的像素数据

Drawable是什么  像一个小型的专注的View

drawable存储的是一个绘制的规则 可能是位图 可能是颜色 等等 和View的绘制基本上一样 只不过上下左右是getBounds()的上下左右

自定义Drawable 有 主要方法是draw方法

自定义Bitmap 没有



#### 触摸反馈

 View.onTouchEvent源码分析

###### ACTION_DOWN

1.判断是否是可点击的 clickable

2.判断是否被设置为disabled 如果被设置了 返回 clickable 

3.判断touchDelegate是否存在 存在消费事件

4.如果 clickable == true || (viewFlags & TOOLTIP) == TOOLTIP 进入事件判断逻辑 否则返回false

(什么是TOOLTIP 就是一个属性 toolTipText  长按时会出现的提示 解释当前view是什么)

5.判断是否是触摸了实体按键(带键盘的手机),设置一个手指按下的flag

6.判断如果 clickable == false `检查长按`(触发toolTip)

7.判断是否是鼠标右键的按下(就是原来手机的那个菜单键) 如果是 显示一个菜单(现在基本无用)

8.判断是否在一个滑动的容器中 如果不是 设置为按下状态 `检查长按 `  ,如果是 设置一个点击等待器

等待器是个runnable runnable执行的代码和按下状态执行的基本一致

###### ACTION_MOVE

1.如果clickable == true,波纹(Ripple)中心 会随着手指改变

2.如果手指已经滑动到view外面  这次的系列事件就算结束  mTouchSlop 溢出 溢出的距离

移除点击和长按的Callback 就不会触发点击和长按事件了

###### ACTION_UP

1.去按下事件的状态

2.如果有TOOLTIP 显示tooltip

3.如果clickable ==false 移除点击和长按的监听 重置状态等

4.isFocusableInTouchMode() 含义 是否可以获取焦点在TouchMode 就是实体按键比如说电视 左右滑动就可以选中View

5.预按下状态的逻辑

6.触发点击时间

###### ACTION_CANCEL

1.初始化所有状态(移除点击事件 初始化状态)

#### ViewGroup 



#### Binder机制

binder三个优点:

高效,数据只需要拷贝一次(相对管道,消息队列,socket) ,共享内存是0次但是太复杂不好用

安全(相对传统IPC,比如socket的ip地址是可以被篡改的)  每个进程有UID

稳定(相对共享内存) 基于CS架构

linux应用的进程空间分为用户空间和内核空间,只有内核空间才可以进行进程间的数据交互

有一个运行在内核空间中的binder驱动程序负责进程的binder通信

传统IPC :`发送方`用户空间 发送数据调用copy_from_user()将数据拷贝到内核空间,`接收方`开辟一块内存空间通过copy_to_user()将数据拷贝到server用户空间 这样就导致了复制了两次数据,`接收方`也不知道数据大小 可能会导致内存浪费

Binder驱动: 接收方发送数据 通过copy_from_user()将数据发送到内核空间缓存区

binder通过内存映射 在内核空间和`接收方`的数据缓存区做了一层内存映射,这样`发送方`的数据拷贝到内核空间缓存区就等于直接拷贝到`接收方`的数据缓存区,等于减少了一次数据拷贝

1.binder驱动在内核空间创建一个 数据接收缓存区

2.再建立一个 内核缓存区 用来存储发送方的数据

3.建立两个缓存区之间的内存映射,以及 数据接收缓存区和数据接收方的内存映射

4.发送方通过系统调用copy_from_user() 将数据copy到内核的内核缓存区,因为内存映射的关系 相当于把数据发送到了数据接收方的用户空间 



 Binder通信流程 : 

1.Server 通过binder驱动 将自己能提供的服务`(binder的引用)`注册到serviceManager,serviceManager会建立一个映射表

2.client通过binder驱动,向serviceManager请求指定名称的Server的binder引用 也就是一个代理对象

3.client拿着这个引用 也就是binder的代理 调用对应服务的对应方法,同过binder驱动 调用到了Server自身的Binder的对应的方法

4.server执行完方法后 再通过binder驱动 将返回值 发送给client

每一步都有binder驱动的存在

对于client来说 binder就是一个server的引用

对于server来说 binder是自己具体实现的对象,要告诉serviceManager

对于serviceManager来说 binder就是binder名字和引用的映射

对于binder驱动来说 binder就是client和server沟通的桥梁



#### AIDL

transact() 远端对象(client端拿到的代理对象) 调用的方法 向server真正的binder对象发出调用

onTransact() 是远端对象(client端拿到的代理对象)能够响应接收到的调用

大概流程(存疑):Proxy.transact() -> Binder.onTransact() ->Proxy拿到结果

in  数据只能从客户端流向服务端

out 数据只能从服务端流向客户端

inout 数据可以双向流入

oneway 立即返回 不需要等待 可能aidl方法要执行两秒 但是我不管 我直接就跳过了 非阻塞



#### Android启动流程

1.开机键引导芯片加载BootLoader到内存 拉起系统OS

​	linux内核启动完毕后  寻找init.rc文件并启动init进程

2.init进程 

​	1 创建一些文件夹并挂载设备 

​	2) 初始化和启动属性服务 

​	3) 解析init.rc配置文件并启动zygote进程 

3.zygote进程 

​	1)创建AppRuntime并调用其start方法，启动Zygote进程。
​	2)创建DVM并为DVM注册JNI.
​	3)通过JNI调用ZygoteInit的main函数进入Zygote的Java框架层。
​	4)通过registerZygoteSocket函数创建服务端Socket，并通过runSelectLoop函数等待	ActivityManagerService的请求来创建新的应用程序进程。

​	5.启动SystemServer进程,通过fork方式启动,进程名为：system_server，启动的类名为：		com.android.server.SystemServer 

	zygoteinit的main方法
						(1) 创建Server端的socket
	
						(2) 预加载类和资源
	
						(3) 启动SystemServer进程
	
						(4) 等待AMS请求创建新的应用程序进程
4.SystemServer 主要用于创建系统服务

​	启动binder线程池

​	创建SystemServiceManager(用于对系统服务进行创建,启动和生命周期管理)

​	启动了各种服务 `优先级引导服务、核心服务和其他服务`  AMS PMS WMS等等

​	AMS启动Launcher应用(桌面)



#### APP启动流程

1.调用activity.startActivityForResult方法  最终转到mInstrumentation.execStartActivity()方法,因为Launcher是一个单独的进程 所以要跨进程告诉系统服务我要启动APP, 然后找到了ATMS(ActivityTaskManagerService) 然后使用AIDL,通过Binder进行通信

ATMS是AMS的一个延伸 之前这些工作都是AMS做的 现在分了一部分给ATMS 主要就是四大组件的调度工作 也是SystemServer启动的 

startActivity之后有一个checkStartActivityResult方法,如果activity启动失败 就会报异常 比如没注册manifest

2.ATMS收到启动消息后,就会通知上一个应用 也就是Launcher,让其进入Paused状态

startPausingLocked 会让上一个应用计入Paused状态 也就是Launcher 然后判断新的应用是否启动,如果启动 就会走ResumeActivityItem 方法 也就是控制Activity的onResume生命周期方法

如果应用没启动 就会走startSpecificActivityLocked 方法

3.ATMS判断应用进程是否已经启动,如果没有启动 创建进程,通过socket和Zygote通信,BufferedWriter读取消息,然后将新建进程消息给Zygote ,Zygote执行fork()方法,创建新进程并返回新进程的pid,

​	(为什么不用Binder? 因为fork不允许多线程,binder是多线程的,还有一点是为了防止死锁,因为假		如某个线程对某个锁lock了,另外一个线程去fork出新的进程,这个新的进程的锁是没人释放的,如果这	个新进程有人再用这个锁lock 就死锁了

4.ActivityThread

Zygote fork进程的同时, 也创建了ActivityThread对象, 也就是进程创建的时候 ActivityThread的main方法就被执行了, main方法创建了ActivityThread 创建主线程Looper并开始循环,并通知AMS,调用AMS.attachApplicationLocked() 方法 启动Application 并启动根Activity

5.创建Application

创建Instrumentation,也就是Launcher.startActivity中的这个Instrumentation 每一个APP都有一个Instrumentation 用于管理这个进程,比如创建activity 就会先执行到这

执行makeApplication 方法,最终执行到newApplication,执行了application的attach方法,然后去执行application的onCreate方法 attach还新建了phoneWindow 建立自己和window的关联等

6.启动activity

attach方法最终执行到ActivityThread的handleLauncheActivity()方法

初始化windowManagerGlobal 也就是WMS 然后创建ContextImpl 启动Activity 初始化activity的数据,设置主体,调用onCreate方法



启动流程简化版:

1.Launcher被调用点击事件,转到Instrumentation类的startActivity方法

2.Instrumentation通过binder告诉AMS要启动APP的需求

3.AMS反馈Launcher 让launcher进入paused状态

4.AMS转到ZygoteProcess类,通过socket和Zygote通信,告诉Zygote要建立新进程

5.Zygote fork新进程,并执行ActivityThread的main方法,也就是app的入口

6.ActivityThreade的main方法 创建ActivityThread的实例,并建立MainLooper 开启循环

7.与此同时ActivityThread也告诉AMS,进程创建完毕,开始创建Application Provider并调用application的attach oncreate等方法

8.创建上下文 通过类加载器加载activity 调用activity的生命周期方法 

启动完毕

#### activity启动流程

activity调用startActivityForResult 最终执行到Instrumentataion的startActivity方法

instrumentation通过binder访问AMS  AMS进行一系列工作,比如activity是否存在,启动模式,是否注册等

然后ClientlifeCycleManager 通过binder访问ActivityThread 

ActivityThread通过instrumentation的类加载器创建activity的实例,然后回调生命周期等方法





#### JVM

JVM结构包含 运行时数据区 执行引擎 本地方法库 本地方法接口 

类加载子系统补数据JVM虚拟机的内部构造

1.类的生命周期

​	一个java文件被加载到java虚拟机内存中到从内存中卸载的过程被称为类的生命周期

包括 加载,链接,初始化,使用,卸载 .链接包含三阶段: 验证,准备,解析 因此类的生命周期包括了7个阶段

​	1) 加载:查找并加载class文件

​	2) 链接:验证,准备 解析

​		验证:确保被导入类型的正确性

​		准备:为类的静态字段分配字段,并使用默认值初始化这个字段

​		解析:虚拟机将常量池内的符号引用替换为直接引用

​	3) 初始化:将类变量初始化为正确的初始值

​	4)使用:

​	5)卸载:

2.运行时数据区域  (JVM内存模型)

主要分为:程序计数器,栈,堆,方法区和本地方法区

​	1) 程序计数器:主要是为了保证程序能够连续的执行下去

​	程序计数器也叫PC寄存器,是一块较小的内存空间,在虚拟机的概念模型中,字节码解释器的工作就是通过改变程序计数器来选取下一条需要执行的字节码指令,java虚拟机的多线程是通过轮流切换并分配处理器执行时间来实现的,在一个确定的时刻只有一个处理器执行一条线程中的指令,因此为了保证线程切换后能回到正确的执行位置,每个线程都有一个独立的程序计数器 所以程序计数器是线程私有的

​	2) 栈:

#### JVM垃圾回收

标记算法:

​	(1)引用技术算法:每个对象加计数器 有引用加1 没有了减少1 到0的时候 就认为没用了 可以GC

但是可能存在A和B两个对象互相引用 这样就导致了A和B都没法回收 所以这个算法一般不用

​	(2)根搜索算法(可达性分析算法),使用一系列的GC Roots的跟对象作为起始节点 根据引用关系向下搜索,走过的路径叫做引用链(Reference Chain),如果一个对象到GC Roots没有任何的引用链相连,就认为此对象可以被回收,就会进行标记

垃圾回收算法:

​	1.标记-清除算法:通过根搜索算法标记出需要回收的对象 然后进行统一回收

​	缺点:对象如果多的话 效率会低 因为要一个一个标记和回收,需要大量的时间

​		会引发内存碎片化问题,回收的对象一般都是不连续的,会产生很多的不连续的内存,然后导致		需要分配大对象的时候没有足够的连续空间

​	2.标记-复制算法

​	把内存划分为相等大小的两块 然后分配对象用其中一块 满了的时候 把存活对象复制到另外一半,然后用了的那块全部清除

​	缺点:相当于内存变成原来的一半,内存使用率低

​	3.编辑-整理算法

​	标记好存活对象之后,把存活的对象一个一个的往内存的一端移动,移动完以后把边界外的内存全部清除掉

新生代和老年代用的算法不同

新生代: Eden和Survivor区域为8:1,使用标记复制算法

老年代:标记-整理算法或标记-清除算法



#### Handler

Looper.prepare():创建Looper对象 messageQueue 并持有当前线程引用

创建线程所属的Looper 先判断ThreadLocal是否持有 持有则报错

```java
private static void prepare(boolean quitAllowed) {
        // 规定了一个线程只有一个Looper，也就是一个线程只能调用一次Looper.prepare()
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        // 如果当前线程没有Looper，那么就创建一个，存到sThreadLocal中
        sThreadLocal.set(new Looper(quitAllowed));
    }
```

new Looper(): 创建messageQueue,并让Looper持有当前线程的引用

```java
 private Looper(boolean quitAllowed) {
        // 创建了MessageQueue，并供Looper持有
        mQueue = new MessageQueue(quitAllowed);
        // 让Looper持有当前线程对象
        mThread = Thread.currentThread();
    }
```

new Handler() :调用Looper.myLooper() 其实是调用sThreadLocal.get(),如果没有looper就抛异常

如果有 就拿到Looper的引用,Looper.messageQueue的引用,callback的引用

Looper.loop() 拿到messageQueue 并开始死循环,不停调用messageQueue.netx()取消息 如果没有 就通过native方法阻塞当前线程,如果有就调用msg.target.dispatchMesage(msg)方法去处理消息,target其实就是发送消息的handler对象,如果是使用callback方式的 就调用callback 如果不是 再判断他的mCallback 是不是空,不是空就调用mCallback.handleMessage并判断返回值,如果返回的是false 就调用handler自身的handleMessage (msg)方法

Looper.loop的作用就是不断的从messageQueue中取出message 并调用其回调方法,最后会执行message的recycleUnchecked方法 判断是否需要回收复用,判断的方法为已缓存的message对象是否超过50个,缓存的是一个单向链表

Handler 发送消息的几个方法 最终都会调用到sendMessageAtTime然后调用enqueueMessage

通过messageQueue自身的enqueueMessage方法,根据延迟的时间,把message放到合适的位置上,

message.Obtain() 先判断是否有缓存 如果有 从缓存中取



#### RecyclerView运行机制

ListView 缓存 RecycleBin里的ActiveView ScrapView

RecyclerView告诉LayoutManager要测量child ,LayoutManager去找Recycler要ViewHolder,Recycler根据是否有缓存来判断是否需要去找Adapter创建新的ViewHolder并返回给LayoutManager,ViewHolder中有itemView,也就是LayoutManager拿到了View 就可以开始测量了



​													RecyclerView

​				LayoutManager			Recycler						Adapter

​				ItemAnimator			ItemDecoration			ViewHolder

LayoutManager 对view进行测量,layout位置的摆放位置等

itemAnimator 提供view的动画

Adapter 把数据列表转换成RecyclerView需要的itemView 也就是提供view

viewHolder 

RecyclerViewPool 可以多个RecyclerView 公用一个回收池 就是直接recyclerView.setRecyclerViewPool. 

可以单独设置最大复用的ViewHolder容量

缓存机制 : 滑动时 先将划出屏幕外的ViewHolder回收到mCachedViews 默认最大值为2,然后 如果这个时候 屏幕划回来 就直接取到这个ViewHolder直接显示出来就可以了, 如果一直滑动  缓存的一直都是最新的2个ViewHolder,超出来的会被回收到RecyclerViewPool,每种类型默认最大缓存5个,

RecyclerViewPool 类似ListView的 RecycleBin的mScrapViews ,mCachedViews类似ListView的mActiveViews 但是ListView的mActiveViews 很少能用到



mAttachedScrap 用于临时保存数据没有变化的ViewHolder 

mChangedScrap 用于临时保存数据已经变化的viewHolder

pre-layout 数据改变前对应的布局 根据adapter给的信息(删除) 后一个item要前移 这样就确定了初始位置  获取mAttachedScrap +mChangedScrap  中的viewholder

 post-layout 数据改变后对应的布局 获取mAttachedScrap 中的viewHolder  无法获取到改变的viewHodler 需要去Pool和cachedView去找(或者新创建) 然后同一位置的两个viewHolder做配合 执行动画

预测性动画

动画需要两个viewHolder的配合 分别进行出场动画和进场动画

如何取消动画: recyclerView.setSupportChangeAnimations(false) 会取消所有的动画 不推荐

adapter.notifyItemChanged(position,"payload") ,就可以做到真正的局部刷新(不闪烁)

获取viewHolder的方法tryGetViewHolderForPositionByDeadline()

1.

- 1.从mAttachedScrap中获取
- 2.从HiddenView中获取
- 3.从CacheView获取

2.hasStablelds  需要对每一个item 设置一个单独的id 这个一般是notifydatasetchanged()的优化

3.ViewCacheExtension  一般没人用

4.RecyclerViewPool 取

都取不到 创建新的

RecyclerView 性能优化

1.onBindViewHolder 创建OnClickListener 不用使用匿名内部类对象,因为onBindViewHolder会执行多次,就会导致OnClickListener被创建多次

优化方式:可以在onCreateViewHolder里创建,或者提前创建好Listener,onBind的时候设置这个监听就可以了

2.LinearLayoutManager.setInitialPrefetchItemCount()

用户滑动的时候 由于需要创建更复杂的view 可能会导致页面卡顿

由于RenderThread的存在, RecyclerView会进行prefetch

setInitialPrefetchItemCount(count) count=横向列表初次显示可见的item个数,就是提前加载一些item 只有LinearLayoutManager切内部嵌套才有用

3.recyclerView.setHasFixedSize() 

如果RecyclerView的大小是固定的 那就可以设置为true 这样就不会重新测量RecyclerView,

4.多个RecyclerView 共享RecyclerViewPool

5.DiffUtil

#### Java多线程



#### 插件化

 动态部署